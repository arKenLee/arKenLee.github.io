<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Ken’s Notes">
<meta property="og:url" content="https://arKenLee.github.io/index.html">
<meta property="og:site_name" content="Ken’s Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ken’s Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://arKenLee.github.io/"/>





  <title> Ken’s Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ken’s Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep Calm and Carry On</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/09/24/Designing for iPhone X and iOS 11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/24/Designing for iPhone X and iOS 11/" itemprop="url">
                  Designing for iPhone X and iOS 11
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-24T18:51:41+08:00">
                2017-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS-11"><a href="#iOS-11" class="headerlink" title="iOS 11"></a>iOS 11</h2><h3 id="Safe-Area-Layout-Guide"><a href="#Safe-Area-Layout-Guide" class="headerlink" title="Safe Area Layout Guide"></a>Safe Area Layout Guide</h3><p>在 iOS 11 中，<code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 这两个属性被标为过期，取而代之的是 <strong>Safe Area（安全区域）</strong>这个概念相关的属性。</p>
<h4 id="1-Safe-Area（安全区域）"><a href="#1-Safe-Area（安全区域）" class="headerlink" title="1. Safe Area（安全区域）"></a>1. Safe Area（安全区域）</h4><p>在 iOS 11 中，苹果引入了一个 <strong>Safe Area</strong> 的概念，即不会被系统元素遮挡的UI安全区域。下面是 iPhone 8 屏幕（4.7英寸）和 iPhone X 屏幕的安全区域对比：</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/contrast_safe_area.png" alt="安全区域对比" title="安全区域对比">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_8_safe_area.png" alt="iPhone 8 竖屏安全区域" title="iPhone 8 竖屏安全区域">

<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_safe_area2.png" alt="iPhone X 横屏安全区域" title="iPhone X 横屏安全区域">
<p>如果是使用系统提供的 UI 元素（例如 <code>UINavigationBar</code>、<code>UITabBar</code>、<code>UITableView</code> 等）会自动适应 iPhone X 的外形。如果是使用自定义的 UI 元素，那么需要自己适配，特别是如果之前隐藏了状态栏的界面，苹果建议在 iPhone X 上最好还是显示状态栏，除非是全屏展示图片或视频以及游戏等。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/safe_area_layout.png" alt="自动调整布局" title="自动调整布局">
<h4 id="2-safeAreaInset"><a href="#2-safeAreaInset" class="headerlink" title="2.safeAreaInset"></a>2.safeAreaInset</h4><p>在 iOS 11 中，<code>UIView</code> 新增了 <code>safeAreaInsets</code> 属性，该属性用来描述被系统提供的 UI 元素遮挡的部分。例如：竖屏状态下带有状态栏及导航栏的 <code>UIViewController.view.safeAreaInsets</code> 的值为 <code>{64, 0, 0, 0}</code> 。其中 <code>safeAreaInsets.top -&gt; 64</code> 表示顶部 64pt 范围内是被导航栏及状态栏遮挡的部分。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> safeAreaInsets: <span class="type">UIEdgeInsets</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>因此可以通过该属性来控制视图的布局，尤其是在 iPhone X 上，可以很好的通过该属性解决顶部的导航栏区域遮挡问题。但不幸的是，该属性在添加到父视图时并不立即生效，而是在 <code>UIViewController.viewWillLayoutSubviews()</code> 之后触发布局刷新时才会生效。</p>
<h4 id="3-safeAreaLayoutGudie"><a href="#3-safeAreaLayoutGudie" class="headerlink" title="3.safeAreaLayoutGudie"></a>3.safeAreaLayoutGudie</h4><p>由于 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 这两个属性被标为过期，被 <code>UIView</code> 的 <code>safeAreaLayoutGuide</code> 取而代之。使用该属性不用担心生效时机，因为这个属性是通过自动布局的方式来使用的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> safeAreaLayoutGuide: <span class="type">UILayoutGuide</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>用法也与之前的一致：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">	<span class="keyword">let</span> topLayoutConstraint = <span class="type">NSLayoutConstraint</span>(item: tableView, attribute: .top, relatedBy: .<span class="built_in">equal</span>, toItem: view.safeAreaLayoutGuide, attribute: .top, multiplier: <span class="number">1</span>, constant: <span class="number">10</span>)</div><div class="line"></div><div class="line">	<span class="keyword">self</span>.view.addConstraint(topLayoutConstraint)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">	tableView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.view.safeAreaLayoutGuide.topAnchor, constant: <span class="number">10</span>).isActive = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于-UIScrollView"><a href="#关于-UIScrollView" class="headerlink" title="关于 UIScrollView"></a>关于 UIScrollView</h3><p>在 iOS 11 中 <code>UIScrollView</code> 增加了几个属性，用来帮助有效的适配内容布局，这里介绍4个属性：</p>
<h4 id="1-adjustedContentInset"><a href="#1-adjustedContentInset" class="headerlink" title="1.adjustedContentInset"></a>1.adjustedContentInset</h4><p>该属性影响 <code>UIScrollView</code> 在安全区域内的展示效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> adjustedContentInset: <span class="type">UIEdgeInsets</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>当 <code>contentInsetAdjustmentBehavior</code> 属性生效时，<code>adjustedContentInset</code> 就会根据相应的行为去调整该值的大小。例如：一个占满屏幕的 <code>UIScrollView</code> 展示在一个竖屏的 iPhone 8 上，并且顶部和底部分别有 <code>UINavigationBar</code> 和 <code>UITabBar</code>，<code>contentInsetAdjustmentBehavior</code> 为默认的 <code>automatic</code>。由于此时的 <code>safeAreaInsets</code> 为 <code>{64, 0, 49, 0}</code>，因此 <code>adjustedContentInset</code> 的值就是 <code>{64, 0, 49, 0}</code>。</p>
<p>而在 iOS 11 以前，<code>UIViewController</code> 是通过改变 <code>contentInset</code> 来影响内容展示。</p>
<h4 id="2-contentInsetAdjustmentBehavior"><a href="#2-contentInsetAdjustmentBehavior" class="headerlink" title="2.contentInsetAdjustmentBehavior"></a>2.contentInsetAdjustmentBehavior</h4><p>这个新增的属性用来替代 <code>UIViewController.automaticallyAdjustsScrollViewInsets</code> ，作用于旧的属性类似，并且还会根据屏幕的显示来调整 <code>UIScroll</code> 的 <code>adjustedContentInset</code> 属性值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> contentInsetAdjustmentBehavior: <span class="type">UIScrollViewContentInsetAdjustmentBehavior</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIScrollViewContentInsetAdjustmentBehavior</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">	<span class="comment">// 自动调整行为，默认值</span></div><div class="line">  	<span class="comment">// 与 scrollableAxes 是相同的。只不过如果 UIScrollView 被放在一个 automaticallyAdjustsScrollViewContentInset 为 YES 并且包含 UINavigationController 的 控制器上，那么在 top 和 bottom 上 adjustedContentInset = safeAreaInset + contentInset，不管是否可以滚动。</span></div><div class="line">	<span class="keyword">case</span> automatic</div><div class="line"> 	<span class="comment">// 在可滚动的方向上 adjustedContentInset = safeAreaInset + contentInset，在不可滚动方向上 adjustedContentInset = contentInset</span></div><div class="line">	<span class="keyword">case</span> scrollableAxes </div><div class="line">	<span class="comment">// 不调整 contentInset 属性值，即 adjustedContentInset = contentInset</span></div><div class="line">	<span class="keyword">case</span> never </div><div class="line">	<span class="comment">// 总是根据 safeAreaInsets 调整 contentInset 属性值，即无论什么情况都是 adjustedContentInset = safeAreaInset + contentInset</span></div><div class="line">	<span class="keyword">case</span> always</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此如果需要全屏展示一个滚动视图时，可以将 <code>adjustedContentInset</code> 设置为 <code>.never</code> 。</p>
<h4 id="3-contentLayoutGuide-与-frameLayoutGuide"><a href="#3-contentLayoutGuide-与-frameLayoutGuide" class="headerlink" title="3.contentLayoutGuide 与 frameLayoutGuide"></a>3.contentLayoutGuide 与 frameLayoutGuide</h4><h3 id="关于-UITableView"><a href="#关于-UITableView" class="headerlink" title="关于 UITableView"></a>关于 UITableView</h3><p>在 iOS 11 中，<code>UITableView</code> 的 Self-Sizing 将被默认开启，rowHeight 不再默认是44，estimatedRowHeight 也不再默认是 0，而是 <code>UITableViewAutomaticDimension</code> 。如果不想使用 Self-Sizing，那么需要显示的设置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tableView.estimatedRowHeight = <span class="number">0</span></div><div class="line">tableView.estimatedSectionHeaderHeight = <span class="number">0</span></div><div class="line">tableView.estimatedSectionFooterHeight = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>如果在以前的代码中只实现了 <code>tableView:heightForHeaderInSection:</code> 或者 <code>tableView:heightForFooterInSection:</code>，但是没有实现 <code>tableView:viewForHeaderInSection:</code> 或者 <code>tableView:viewForFooterInSection:</code> 。在 iOS 11 中由于新的估算行高机制会引起虽然设置了表头和表尾高度为0，但依然还会有留白的情况。</p>
<p>解决办法就是实现 <code>tableView:viewForHeaderInSection:</code> 或者 <code>tableView:viewForFooterInSection:</code> ，或者将 <code>UITableView</code> 的估算属性（<code>estimatedSectionHeaderHeight</code>、<code>estimatedSectionFooterHeight</code>）设置为0。</p>
<h3 id="关于导航栏与标签栏"><a href="#关于导航栏与标签栏" class="headerlink" title="关于导航栏与标签栏"></a>关于导航栏与标签栏</h3><p>从 iOS 11 开始，苹果为 UIKit’s Bars 增加了一些新的特性：1.原本导航栏上的标题可以显示为大标题状态，当往上滚动时变为原来的导航栏标题效果；2.在横屏状态下 UITabBarItem 上的图标和文字就会变为横向显示。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/large_title1.png" alt="Large Title" title="Large Title">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/large_title2.png" alt="Normal Title" title="Normal Title">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/tab_bar_item.png" alt="Landscape UITabBarItem" title="Landscape UITabBarItem">
<p>设置 <code>UINavigationBar.prefersLargeTitles</code> 可以设置大标题视图，同时 <code>UINavigationItem.largeTitleDisplayMode</code> 也会影响大标题的显示效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UINavigationBar</span></div><div class="line">open <span class="keyword">var</span> prefersLargeTitles: <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// UINavigationItem</span></div><div class="line"><span class="comment">// 该属性只有才 prefersLargeTitles 启用后才生效</span></div><div class="line">open <span class="keyword">var</span> largeTitleDisplayMode: <span class="type">UINavigationItem</span>.<span class="type">LargeTitleDisplayMode</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LargeTitleDisplayMode</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">	<span class="comment">// 自动显示和隐藏大标题视图，默认与上一个 navigationItem.largeTitleDisplayMode 一致，默认值</span></div><div class="line">	<span class="keyword">case</span> automatic</div><div class="line">	<span class="comment">// 不管之前的 UIViewController 中的标题设置为什么显示样式，当前的 viewController 则总是显示大标题(往上滚动时还是可以收起大标题)</span></div><div class="line">	<span class="keyword">case</span> always</div><div class="line">	<span class="comment">// 从不显示大标题</span></div><div class="line">	<span class="keyword">case</span> never</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于搜索栏"><a href="#关于搜索栏" class="headerlink" title="关于搜索栏"></a>关于搜索栏</h3><h4 id="1-在导航栏中的搜索控制器"><a href="#1-在导航栏中的搜索控制器" class="headerlink" title="1.在导航栏中的搜索控制器"></a>1.在导航栏中的搜索控制器</h4><p>在 iOS 11 中，导航栏上的搜索控制器不再是以 present 形式展示，而是直接设置给 <code>self.navigationItem.searchController</code> 。</p>
<p>将搜索控制器的 <code>isActive</code> 属性设置为 <code>true</code> 可以激活搜索控制器并开始编辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="function"><span class="keyword">func</span> <span class="title">presentSearchController</span><span class="params">(initialSearchText searchText: String? = <span class="literal">nil</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> searchController = <span class="type">UISearchController</span>(searchResultsController: <span class="literal">nil</span>)</div><div class="line">    searchController.searchResultsUpdater = <span class="keyword">self</span></div><div class="line">    searchController.obscuresBackgroundDuringPresentation = <span class="literal">false</span></div><div class="line">    searchController.searchBar.text = searchText</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">        <span class="keyword">self</span>.navigationItem.searchController = searchController</div><div class="line">        searchController.isActive = <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        present(searchController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过 <code>hidesSearchBarWhenScrolling</code> 属性控制用户在滑动屏幕时自动隐藏搜索栏</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 滚动视图时是否自动隐藏搜索栏，默认为 true</span></div><div class="line">open <span class="keyword">var</span> hidesSearchBarWhenScrolling: <span class="type">Bool</span></div></pre></td></tr></table></figure>
<h4 id="2-UITableView中的搜索控制器"><a href="#2-UITableView中的搜索控制器" class="headerlink" title="2.UITableView中的搜索控制器"></a>2.UITableView中的搜索控制器</h4><p>在 iOS 11 中，设置在 <code>UITableView.tableHeaderView</code>  的搜索栏也可以集成到导航栏中，作为视图控制器的导航项。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="function"><span class="keyword">func</span> <span class="title">showSearchBar</span><span class="params">(showSearchBar: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">        <span class="keyword">self</span>.navigationItem.searchController = <span class="keyword">self</span>.searchController</div><div class="line">        <span class="keyword">self</span>.searchController.isActive = showSearchBar</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> showSearchBar &#123;</div><div class="line">            <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.searchController.searchBar</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">self</span>.tableView.tableHeaderView = <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h2><h3 id="iPhone-X-的变化"><a href="#iPhone-X-的变化" class="headerlink" title="iPhone X 的变化"></a>iPhone X 的变化</h3><p>iPhone X 相比于以往发布的手机在屏幕尺寸和分辨率都发生了很大的变化，它搭载的屏幕是一块全屏的超视网膜显示屏，四周留下圆角，顶部则是一块内嵌各种传感器的凹槽，底部的虚拟Home键指示器替代了物理的Home键。全屏幕的展示提供了更棒的沉浸式体验空间。</p>
<p>iPhone X 的屏幕尺寸为 5.8 英寸，宽度与 4.7 英寸的手机相同为 375pt，高度则为 812 pt ，多出 145pt 的空间。所采取的图片倍数是 3x 图片。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_screen_size.png" alt="iPhone X 屏幕尺寸" title="iPhone X 屏幕尺寸">
<p>至此 iPhone 的各型号尺寸如下：</p>
<table>
<thead>
<tr>
<th>手机型号</th>
<th>开发尺寸</th>
<th>像素尺寸</th>
<th>屏幕尺寸</th>
<th>像素密度</th>
<th>图片倍数</th>
</tr>
</thead>
<tbody>
<tr>
<td>4/4S</td>
<td>320pt × 480pt</td>
<td>640px  × 960px</td>
<td>3.5英寸</td>
<td>326ppi</td>
<td>@2x</td>
</tr>
<tr>
<td>5/5S/5C</td>
<td>320pt × 568pt</td>
<td>640px  × 1136px</td>
<td>4.0英寸</td>
<td>326ppi</td>
<td>@2x</td>
</tr>
<tr>
<td>6/6S/7/8</td>
<td>375pt × 667pt</td>
<td>750px  × 1334px</td>
<td>4.7英寸</td>
<td>326ppi</td>
<td>@2x</td>
</tr>
<tr>
<td>6+/6S+/7+/8</td>
<td>414pt × 736pt</td>
<td>1242px × 2208px</td>
<td>5.5英寸</td>
<td>401ppi</td>
<td>@3x</td>
</tr>
<tr>
<td>X</td>
<td>375pt × 812pt</td>
<td>1125px × 2436px</td>
<td>5.8英寸</td>
<td>458ppi</td>
<td>@3x</td>
</tr>
</tbody>
</table>
<h3 id="iPhone-X-布局"><a href="#iPhone-X-布局" class="headerlink" title="iPhone X 布局"></a>iPhone X 布局</h3><p>在设计 iPhone X 的 UI 时必须确保布局填充屏幕，并且不会被设备的四个圆角以及传感器凹槽、Home键指示器所遮盖。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_safe_layout.png" alt="填充屏幕" title="填充屏幕">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_layout1.png" alt="填充屏幕" title="填充屏幕">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_layout2.png" alt="不要被系统元素遮盖" title="不要被系统元素遮盖">
<p>相比于其他手机，iPhone X 在竖屏的情况下状态栏是 44pt，比传感器凹槽的高度略高一点。底部的 Home 键指示器区域为 34pt，比指示器高度略高。横屏时状态栏是 20pt，Home 键指示器区域为21pt。</p>
<h4 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h4><p>如果你的 <code>UIScrollView</code> 及其子类（例如：<code>UITableView</code> 等），虽然虚拟 Home 键指示器可能会遮挡视图的内容，但因为可以上下滚动因此苹果建议这种滚动的视图在可以贴合底部布局而不是被限制在 Safe Area 中，只要底部的边距预留足够的空间。可以通过 <code>UIScrollView.contentInsetAdjustmentBehavior</code> 属性来调整，该属性默认为 <code>.automatic</code> 即系统会处理超出安全区域外的内容显示，而不需要过多的操心。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_tableview1.png" alt="UITableView" title="UITableView">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_tableview2.png" alt="UITableView" title="UITableView">
<h4 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h4><p>在 iPhone X 中，<code>UITableViewCell.contentView</code> 默认会被嵌到 <strong>Safe Area</strong> 中，如果布局是相对于 <code>contentView</code> 来布局，那么内容将会自适应而不用单独适配 iPhone X 尺寸。如果 <code>contentView</code>  没有开启 insert to safe area，那么 contentView 就会铺满屏幕，但可以通过 <code>layoutMargins</code> 来适配（<code>insetsLayoutMarginsFromSafeArea</code> 需要设置为 <code>true</code>，该属性默认值为 <code>true</code>）。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/tableview_safe_area1.png" alt="UITableView" title="UITableView">
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/tableview_safe_area2.png" alt="UITableView" title="UITableView">
<h3 id="虚拟-Home-键指示器"><a href="#虚拟-Home-键指示器" class="headerlink" title="虚拟 Home 键指示器"></a>虚拟 Home 键指示器</h3><p>在 iPhone X 上取消了物理 Home 键，取而代之的是底部一条虚拟 Home 键指示器，用户通过向上滑动指示器来回到主屏幕和切换App，因此在布局时尽量不要将控件放置在 Home 键指示器附近。</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/iPhone_X_safe_area3.png" alt="在安全区域内放置控件" title="在安全区域内放置控件">
<p>iOS 会动态调整 Home 键指示器的外观颜色，保持与背景之间有效的对比。但只有黑色和白色两种颜色，无法自定义。</p>
<p>苹果允许通过 <code>UIViewController</code> 的 <code>setNeedsUpdateOfHomeIndicatorAutoHidden</code> 方法来自动隐藏 Home 键指示器。</p>
<p>通过重载<code>UIViewController</code> 的 <code>prefersHomeIndicatorAutoHidden</code> 方法，可以让用户在没有触摸屏幕几秒后自动隐藏 Home 键指示器，用户需要再次触摸才会重新出现。</p>
<p>通过这些方法可以在全屏展示内容时为用户提供更好的交互体验。例如在设计全屏幕展示的视频播放界面时，可以先隐藏指示器，等到用户触摸屏幕时再出现。</p>
<p>如果App有类似于底部上滑，或者是顶部下滑的交互功能，可以通过重载 <code>UIViewController</code> 的 <code>preferredScreenEdgesDeferringSystemGestures</code> 方法来推迟系统（通知中心和控制中心）的手势识别。可以让用户在第二次操作时才会触发系统的手势。</p>
<h3 id="Launch-Screen"><a href="#Launch-Screen" class="headerlink" title="Launch Screen"></a>Launch Screen</h3><p>如果 App 的启动屏是通过 Launch Image Source 来提供的，并且在没有提供 1125px * 2436px 的启动图的情况下，那么在 iPhone X 上的界面就会在顶部和底部留下黑边而不是充满整个屏幕。</p>
<p>如果不想留下黑色区域，请配置 1125px * 2436px 的启动图或者使用 Launch Screen.storyboard。</p>
<h2 id="一些遗留问题"><a href="#一些遗留问题" class="headerlink" title="一些遗留问题"></a>一些遗留问题</h2><p>不知道为什么在 iOS 11 上，往 view 添加两个或两个以上的 <code>UITextField</code> 总不能及时的被释放。按照开发者论坛上的说法 [<strong><a href="https://forums.developer.apple.com/message/285674#285674" target="_blank" rel="external">点击这里跳转</a></strong>]这不是一个内存泄漏问题，因为被 <code>UIKeyboard</code> 的一个内部指针持有导致一致不释放，直到下一个 <code>UITextField</code> 成为激活状态之前的才会被释放，但并非不断创建而一直无法释放，因此这不是一个内存泄漏的问题。</p>
<p>在 iOS 11.2 后，有人提出了以下解决方法：</p>
<img src="/2017/09/24/Designing%20for%20iPhone%20X%20and%20iOS%2011/UITextField_memory_leak.png" alt="UITextField memory leak" title="UITextField memory leak">
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)didMoveToWindow  </div><div class="line">&#123;  </div><div class="line">    [super didMoveToWindow];  </div><div class="line">    if (@available(iOS 11.2, *)) &#123;  </div><div class="line">        NSString *keyPath = @&quot;textContentView.provider&quot;;  </div><div class="line">        @try &#123;  </div><div class="line">            if (self.window) &#123;  </div><div class="line">                id provider = [self valueForKeyPath:keyPath];  </div><div class="line">                if (!provider &amp;&amp; self.wmb_originalProvider) &#123;  </div><div class="line">                    [self setValue:self.wmb_originalProvider forKeyPath:keyPath];  </div><div class="line">                &#125;  </div><div class="line">            &#125; else &#123;  </div><div class="line">                self.wmb_originalProvider = [self valueForKeyPath:keyPath];  </div><div class="line">                [self setValue:nil forKeyPath:keyPath];  </div><div class="line">            &#125;  </div><div class="line">        &#125; @catch (NSException *exception) &#123;  </div><div class="line">            NSLog(@&quot;%@&quot;, exception);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/videos/play/fall2017/801/" target="_blank" rel="external">[1] Designing for iPhone X</a></p>
<p><a href="https://developer.apple.com/videos/play/fall2017/201" target="_blank" rel="external">[2] Building Apps for iPhone X</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/412" target="_blank" rel="external">[3] Auto Layout Techniques in Interface Builder</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/219" target="_blank" rel="external">[4] Modern User Interaction on iOS</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/204" target="_blank" rel="external">[5] Updating Your App for iOS 11</a></p>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="external">[6] Human Interface Guidelines - iPhone X</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="external">[7] Auto Layout Guide</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/07/24/In-App-Purchase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/24/In-App-Purchase/" itemprop="url">
                  In-App Purchase
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-24T23:02:32+08:00">
                2017-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SKPaymentTransaction"><a href="#SKPaymentTransaction" class="headerlink" title="SKPaymentTransaction"></a>SKPaymentTransaction</h3><p>// transactionIdentifier 和 transactionDate 只有 SKPaymentTransactionStatePurchased or SKPaymentTransactionStateRestored 状态才有值</p>
<p>​                </p>
<p>​                // transactionReceipt 只有 SKPaymentTransactionStatePurchased 状态才有值</p>
<p>// error 只有 SKPaymentTransactionFailed 状态才会有值</p>
<p>// original 只有 SKPaymentTransactionStateRestored 状态才会有值</p>
<p>// transactionIdentifier 和 transactionDate 只有 SKPaymentTransactionStatePurchased or SKPaymentTransactionStateRestored 状态才有值</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/07/02/线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/线程安全/" itemprop="url">
                  线程安全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T11:48:52+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thread/" itemprop="url" rel="index">
                    <span itemprop="name">Thread</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在 iOS 开发过程中经常会使用多线程处理耗时操作，在不同线程对同一个数据进行操作时，不可避免的就会出现数据不一致的情况。尤其是单例模式，由于全局仅有一个实例，在不同线程中改写单例的数据是非常危险的。为了避免这种情况通常可以采用加锁、使用信号量或者使用队列来保证线程的安全。</p>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>线程锁按功能划分可以分为：互斥锁、自旋锁、条件锁、递归锁、分布锁等，按照不同用途可以采用合适的锁。</p>
<p>OC层面常见的6个锁：NSLock、NSRecursiveLock、NSCondition、NSConditionLock、@synchronized、NSDistributedLock。</p>
<p>C语言层面常见的锁：OSSpinLock、pthread_mutex、pthread_spin、pthread_con、pthread_rwlock。</p>
<h3 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h3><h4 id="1-NSLock"><a href="#1-NSLock" class="headerlink" title="1.NSLock"></a>1.NSLock</h4><p><code>NSLock</code> 是OC层面的锁，继承自 <code>NSObject</code>，创建和使用都非常简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">[lock lock];</div><div class="line">// do something</div><div class="line">[lock unlock];</div></pre></td></tr></table></figure>
<h4 id="2-NSLock-IMP"><a href="#2-NSLock-IMP" class="headerlink" title="2.NSLock + IMP"></a>2.NSLock + IMP</h4><p>使用 <code>NSLock</code> 时可以直接取出加锁和解锁的 <code>IMP</code> 直接执行，效率比直接使用方法略高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef void (*func)(id, SEL);</div><div class="line"></div><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">SEL lockSEL = @selector(lock);</div><div class="line">SEL unlockSEL = @selector(unlock);</div><div class="line"></div><div class="line">func lockFunc = (void (*)(id, SEL))[lock methodForSelector:lockSEL];</div><div class="line">func unlockFunc = (void (*)(id, SEL))[lock methodForSelector:unlockSEL];</div><div class="line"></div><div class="line">lockFunc(lock, lockSEL);</div><div class="line">// do something</div><div class="line">unlockFunc(lock, unlockSEL)</div></pre></td></tr></table></figure>
<h4 id="3-synchronized"><a href="#3-synchronized" class="headerlink" title="3.@synchronized"></a>3.@synchronized</h4><p>这个是Objective-C语法级的锁，简单易用，但性能较差</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@synchronized(self) &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-Pthread-mutex"><a href="#4-Pthread-mutex" class="headerlink" title="4.Pthread mutex"></a>4.Pthread mutex</h4><p>C级别的锁，从 2.6.x 系列稳定版内核开始<br>需要引入头文件： <code>#include &lt;pthread.h&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// --------- 作为变量使用 ---------</div><div class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;mutex);</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line"></div><div class="line">// --------- 作为属性使用 ---------</div><div class="line">// 如果作为属性，不能用该宏来初始化</div><div class="line">pthread_mutex_init(&amp;_mutex, NULL);</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;_mutex);</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;_mutex);</div><div class="line"></div><div class="line">// 对象销毁时要把锁销毁</div><div class="line">pthread_mutex_destroy(&amp;_mutex);</div><div class="line"></div><div class="line"></div><div class="line">// --------- Swift 中使用 pthread_mutex ---------</div><div class="line">var lock = pthread_mutex_t()</div><div class="line"></div><div class="line">pthread_mutex_init(&amp;lock, nil)</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;lock)</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;lock)</div><div class="line"></div><div class="line">pthread_mutex_destroy(&amp;lock)</div></pre></td></tr></table></figure>
<h4 id="5-NSCondition"><a href="#5-NSCondition" class="headerlink" title="5.NSCondition"></a>5.NSCondition</h4><p>NSCondition 是互斥锁和条件锁的结合，实际上作为一个锁和一个线程检查器：锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞</p>
<p>NSCondition 的几个方法：</p>
<ul>
<li>-lock: 其他线程命令在lock外等待</li>
<li>-unlock: 解除锁</li>
<li>-wait: 让当前线程处于等待状态</li>
<li>-waitUntilDate: 等待一段时间</li>
<li>-signal: CPU 发信号任意通知线程不用等待可以继续执行</li>
<li>broadcast: CPU 通知所有等待的线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">_myCondition = [[NSCondition alloc] init];</div><div class="line"></div><div class="line">- (void)method1 &#123;</div><div class="line">    NSLog(@&quot;STARTING METHOD 1&quot;);</div><div class="line">    NSLog(@&quot;WILL LOCK METHOD 1&quot;);</div><div class="line"></div><div class="line">    [_myCondition lock];</div><div class="line"></div><div class="line">    NSLog(@&quot;DID LOCK METHOD 1&quot;);</div><div class="line"></div><div class="line">    while (!_someCheckIsTrue) &#123;</div><div class="line">        NSLog(@&quot;WILL WAIT METHOD 1&quot;);</div><div class="line">        [_myCondition wait];</div><div class="line">        NSLog(@&quot;DID WAIT METHOD 1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSLog(@&quot;WILL UNLOCK METHOD 1&quot;);</div><div class="line"></div><div class="line">    [_myCondition unlock];</div><div class="line"></div><div class="line">    NSLog(@&quot;DID UNLOCK METHOD 1&quot;);</div><div class="line">    NSLog(@&quot;ENDING METHOD 1&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)method2 &#123;</div><div class="line">    NSLog(@&quot;STARTING METHOD 2&quot;);</div><div class="line">    NSLog(@&quot;WILL LOCK METHOD 2&quot;);</div><div class="line">  </div><div class="line">    [_myCondition lock];</div><div class="line">  </div><div class="line">    NSLog(@&quot;DID LOCK METHOD 2&quot;);</div><div class="line"></div><div class="line">    _someCheckIsTrue = YES;</div><div class="line"></div><div class="line">    NSLog(@&quot;WILL SIGNAL METHOD 2&quot;);</div><div class="line"></div><div class="line">    [_myCondition signal];</div><div class="line"></div><div class="line">    NSLog(@&quot;DID SIGNAL METHOD 2&quot;);</div><div class="line">    NSLog(@&quot;WILL UNLOCK METHOD 2&quot;);</div><div class="line"></div><div class="line">    [_myCondition unlock];</div><div class="line"></div><div class="line">    NSLog(@&quot;DID UNLOCK METHOD 2&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后打印结果依次是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. STARTING METHOD 1</div><div class="line">2. WILL LOCK METHOD 1</div><div class="line">3. DID LOCK METHOD 1</div><div class="line">4. WILL WAIT METHOD 1</div><div class="line">5. STARTING METHOD 2</div><div class="line">6. WILL LOCK METHOD 2</div><div class="line">7. DID LOCK METHOD 2</div><div class="line">8. WILL SIGNAL METHOD 2</div><div class="line">9. DID SIGNAL METHOD 2</div><div class="line">10. WILL UNLOCK METHOD 2</div><div class="line">11. DID WAIT METHOD 1</div><div class="line">12. DID UNLOCK METHOD 2</div><div class="line">13. WILL UNLOCK METHOD 1</div><div class="line">14. DID UNLOCK METHOD 1</div><div class="line">15. ENDING METHOD 1</div></pre></td></tr></table></figure>
<h3 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h3><h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>需要引入头文件：<code>#include &lt;libkern/OSAtomic.h&gt;</code><br>C级别的自旋锁，不过由于OSSpinLock有点问题，可以使用 pthread_mutex 替代，苹果内部目前的锁大多数都替换为这个，并且进行了优化，效率接近自旋锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">OSSpinLock spinLock = OS_SPINLOCK_INIT;</div><div class="line"></div><div class="line">OSSpinLockLock(&amp;spinLock);</div><div class="line">// do something</div><div class="line">OSSpinLockUnlock(&amp;spinLock);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// Swift 中使用 OSSpinLock</div><div class="line">var spinLock = OS_SPINLOCK_INIT</div><div class="line"></div><div class="line">OSSpinLockLock(&amp;spinLock)</div><div class="line">// do something</div><div class="line">OSSpinLockUnlock(&amp;spinLock)</div></pre></td></tr></table></figure>
<blockquote>
<p>不再安全的OSSpinLock: <a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/</a></p>
</blockquote>
<h3 id="条件锁（Condition-Lock）"><a href="#条件锁（Condition-Lock）" class="headerlink" title="条件锁（Condition Lock）"></a>条件锁（Condition Lock）</h3><h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>为了方便对某个线程可能只对某个条件的锁感兴趣，可以通过条件来获取锁的状态。最常见的应用是生产者、消费者模型中消费者关心的 NSConditionLock 通过 condition 属性来判别条件是否成立。</p>
<p><code>NSConditionLock</code> 的属性及方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 这属性非常重要，外部传入的condition与之相同才会获取到lock对象，反之阻塞当前线程，直到condition相同</div><div class="line">@property (readonly)NSInteger condition; </div><div class="line"></div><div class="line">// 指定初始化方法</div><div class="line">- (instancetype)initWithCondition:(NSInteger)conditionNS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">// NSLocking 的两个方法</div><div class="line">- (void)lock;</div><div class="line">- (void)unlock;</div><div class="line"></div><div class="line">// condition与内部相同才会获取锁对象并立即返回，否则阻塞线程直到condition相同</div><div class="line">- (void)lockWhenCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">// 尝试获取锁对象，获取成功需要配对unlock</div><div class="line">- (BOOL)tryLock;</div><div class="line"></div><div class="line">//同上</div><div class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">//解锁，并且设置lock.condition = condition</div><div class="line">- (void)unlockWithCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)executeLock &#123;</div><div class="line">    NSConditionLock* lock = [[NSConditionLock alloc] init];</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        for (NSUInteger i=0; i&lt;3; i++) &#123;</div><div class="line">            sleep(2);</div><div class="line">            if (i == 2) &#123;</div><div class="line">                [lock lock];</div><div class="line">                [lock unlockWithCondition:i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        sleep(1);</div><div class="line">        [self threadMethod:lock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        sleep(1);</div><div class="line">        [self threadMethod:lock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)threadMethod:(NSConditionLock *)lock &#123;</div><div class="line">    [lock lockWhenCondition:2];</div><div class="line">    [lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归锁（Recursive-Lock）"><a href="#递归锁（Recursive-Lock）" class="headerlink" title="递归锁（Recursive Lock）"></a>递归锁（Recursive Lock）</h3><h4 id="1-NSRecursiveLock"><a href="#1-NSRecursiveLock" class="headerlink" title="1.NSRecursiveLock"></a>1.NSRecursiveLock</h4><p>避免在同一线程中多次获取该锁（lock会造成等待锁的unlock，如果加上trylock则不存在问题）导致的死锁问题，使用 <code>NSRecursiveLock</code> 就可以在同一线程中多次加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveBlock)(int);</div><div class="line"></div><div class="line">    RecursiveBlock = ^(int value) &#123;</div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveBlock(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line">    RecursiveBlock(5);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    sleep(2);</div><div class="line">    </div><div class="line">    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];</div><div class="line">    if (flag) &#123;</div><div class="line">        NSLog(@&quot;lock before date&quot;);</div><div class="line">        [lock unlock];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;fail to lock before date&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. value = 5</div><div class="line">2. value = 4</div><div class="line">3. fail to lock before date</div><div class="line">4. value = 3</div><div class="line">5. value = 2</div><div class="line">6. value = 1</div></pre></td></tr></table></figure>
<h4 id="2-pthread-mutex-recursive"><a href="#2-pthread-mutex-recursive" class="headerlink" title="2.pthread_mutex(recursive)"></a>2.pthread_mutex(recursive)</h4><p>需要引入头文件：<code>#include &lt;pthread.h&gt;</code></p>
<p>通过 pthread_mutexattr 将锁设置为递归锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_t lock;</div><div class="line">pthread_mutexattr_t attr;</div><div class="line"></div><div class="line">pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认</div><div class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁</div><div class="line"></div><div class="line">pthread_mutex_init(&amp;lock, &amp;attr);</div><div class="line">pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void(^RecursiveBlock)(int);</div><div class="line"></div><div class="line">    RecursiveBlock = ^(int value) &#123;</div><div class="line">        pthread_mutex_lock(&amp;lock);</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            NSLog(@“value = %d&quot;, value);</div><div class="line">            RecursiveBlock(value - 1);</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;lock);</div><div class="line">    &#125;;</div><div class="line">    RecursiveBlock(5);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. value = 5</div><div class="line">2. value = 4</div><div class="line">3. value = 3</div><div class="line">4. value = 2</div><div class="line">5. value = 1</div></pre></td></tr></table></figure>
<h3 id="读写锁（Read-write-Lock）"><a href="#读写锁（Read-write-Lock）" class="headerlink" title="读写锁（Read-write Lock）"></a>读写锁（Read-write Lock）</h3><h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><p>需要引入头文件：<code>#include &lt;pthread.h&gt;</code><br>效率比递归锁差，比条件锁好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)initLock &#123;</div><div class="line">    pthread_rwlock_init(&amp;_rwlock, NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 写加锁</div><div class="line">-(void)writingLock:(NSString *)temp &#123;</div><div class="line">    pthread_rwlock_wrlock(&amp;_rwlock);</div><div class="line">    // writing</div><div class="line">    self.rwStr = temp;</div><div class="line">    NSLog(@&quot;%@&quot;, temp);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 读加锁</div><div class="line">- (NSString *)readingLock &#123;</div><div class="line">    pthread_rwlock_rdlock(&amp;_rwlock);</div><div class="line">    // reading</div><div class="line">    NSString *str = self.rwStr;</div><div class="line">    NSLog(@&quot;reading = %@&quot;,self.rwStr);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">    return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分布锁（Didtributed-Lock）"><a href="#分布锁（Didtributed-Lock）" class="headerlink" title="分布锁（Didtributed Lock）"></a>分布锁（Didtributed Lock）</h3><h4 id="NSDistributedLock（macOS）"><a href="#NSDistributedLock（macOS）" class="headerlink" title="NSDistributedLock（macOS）"></a>NSDistributedLock（macOS）</h4><p>如果是Mac开发，除了解决多线程冲突外，还需要解决进程间的冲突。跨进程的分布式锁，是进程间同步的工具，底层是用文件系统实现的互斥锁，并不强制进程休眠，而是起到告知的作用。</p>
<p><code>NSDistributedLock</code> 没有实现 <code>NSLocking</code> 协议，所以没有会阻塞线程的 <code>-lock</code>方法，取而代之的是非阻塞的<code>-tryLock</code> 方法来获取锁，用<code>-unlock</code> 方法释放锁。</p>
<p>如果一个获取锁的进程在释放锁之前就退出了，那么锁就一直不能释放，此时可以通过 <code>-breakLock</code> 强行获取锁。</p>
<p><code>NSDistributedLock</code> 的初始化方法需要一个文件或文件夹路径，如果路径目标文件或文件夹不存在，那么在 <code>-tryLock</code> 返回 <code>YES</code> 时，系统会自动创建该文件或文件夹，在结束时该文件或文件夹会被清除,因此可以选择一个不存在的路径防止系统误删文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// app 1</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    _lock = [[NSDistributedLock alloc] initWithPath:@&quot;a path&quot;];</div><div class="line">    [_lock breakLock];</div><div class="line">    [_lock tryLock];</div><div class="line">    sleep(1);</div><div class="line">    [_lock unlock];</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// app2</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    _lock = [[NSDistributedLock alloc] initWithPath:@&quot;/Users/Kenmu/Desktop/earning__&quot;];</div><div class="line">    while (![_lock tryLock]) &#123;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    [_lock unlock];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>除了使用线程锁保证线程安全外，通过GCD也可以达到同样的效果。</p>
<h3 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore 信号量"></a>dispatch_semaphore 信号量</h3><p>通过信号量的增减来保证线程安全，信号量在初始化的时候决定，当信号量为0时阻塞当前线程，大于1时继续运行：</p>
<ul>
<li>使用 <code>dispatch_semaphore_wait</code> 方法让信号量-1，达到 lock 的效果</li>
<li>通过 <code>dispatch_semaphore_signal</code> 让信号量+1，达到 unlock 的效果</li>
</ul>
<p>初始信号量为0，通过overTime让其继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//传入值必须 &gt;=0, 若传入为0则阻塞线程并等待timeout,时间到后会执行其后的语句</div><div class="line">dispatch_semaphore_t dsema = dispatch_semaphore_create(0); </div><div class="line"></div><div class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    dispatch_semaphore_wait(dsema, overTime); //signal 值 -1</div><div class="line">    // do somethine</div><div class="line">    dispatch_semaphore_signal(dsema); //signal 值 +1</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    dispatch_semaphore_wait(dsema, overTime);</div><div class="line">    // do something</div><div class="line">    dispatch_semaphore_signal(dsema);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>初始信号量为1，等待时间为 DISPATCH_TIME_FOREVER，根据信号量实现线程安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line"></div><div class="line">dispatch_semaphore_t dsema = dispatch_semaphore_create(1);</div><div class="line"></div><div class="line">NSMutableArray *array = [NSMutableArrayarray];</div><div class="line"></div><div class="line">for (int index = 0; index &lt; 100000; index++) &#123;</div><div class="line"></div><div class="line">    dispatch_async(queue, ^()&#123;</div><div class="line"></div><div class="line">        dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);</div><div class="line">        NSLog(@&quot;addd :%d&quot;, index);</div><div class="line">        [array addObject:[NSNumber numberWithInt:index]];</div><div class="line">        dispatch_semaphore_signal(dsema);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Barrier-栅栏"><a href="#Barrier-栅栏" class="headerlink" title="Barrier 栅栏"></a>Barrier 栅栏</h3><p>并发队列的栅栏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)initQueue &#123;</div><div class="line">    _queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getter</div><div class="line">- (NSString *)name &#123;</div><div class="line">    __block NSString result = nil;</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">         result = _name;</div><div class="line">    &#125;);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// setter</div><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    dispatch_barrier_sync(_queue, ^&#123;</div><div class="line">         _name = name;</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    // 如果写操作是比较耗时的，可以采用异步栅栏，比如写文件操作</div><div class="line">    // 如果操作不耗时，用同步栅栏会比异步栅栏快是因为异步执行时，需要拷贝块</div><div class="line">    // 如果拷贝块的时间超过执行时间，那么异步会比较慢</div><div class="line">//    dispatch_barrier_async(_queue, ^&#123;</div><div class="line">//         _name = name;</div><div class="line">//    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Serial-Queue-串行队列"><a href="#Serial-Queue-串行队列" class="headerlink" title="Serial Queue 串行队列"></a>Serial Queue 串行队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)initQueue &#123;</div><div class="line">    _queue = dispatch_queue_create(&quot;com.company.app.syncQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getter</div><div class="line">- (NSString *)name &#123;</div><div class="line">    __block NSString result = nil;</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">        result = _name;</div><div class="line">    &#125;);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// setter</div><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    // 如果写操作是比较耗时的，可以采用异步执行，理由见上</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">        _name = name;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/04/30/AVPlayer-iOS在线播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/AVPlayer-iOS在线播放/" itemprop="url">
                  AVPlayer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T22:46:32+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过 <code>AVKit</code> 可以轻松实现在线播放音视频，如果需要自定义播放界面则可以通过 <code>AVPlayer</code> + <code>AVPlayerLayer</code> 实现。并且与 <code>AVAudioPlayer</code> 不同，<code>AVPlayer</code> 支持播放本地音频、视频、流媒体数据，功能强大并且可扩展性高。</p>
<p><code>AVPlayer</code> 本身只是个控制器，通过 <code>AVPlayerItem</code> （充当播放资源选项）获取可播放的资源，并最终展示在 <code>AVPlayerLayer</code> 上。如果以MVC划分：那么 <code>AVPlayerItem</code> 处于 Model 层负责提供数据资源；<code>AVPlayerLayer</code> 处于 View 层负责像用户展示画面；<code>AVPlayer</code> 处于 Controller 层负责两者之间的数据通信，以及管理和控制音视频媒体的播放。</p>
<p><code>AVPlayerItem</code> 底层的资源则是通过 <code>AVAsset</code> 及其子类加载。其中 <code>AVURLAsset</code> 有个 <code>AVAssetResourceLoader</code> 类型的资源加载器属性，如果有更深层次的缓存需求，可以自定义资源下载管理类，通过 <code>AVAssetResourceLoaderDelegate</code> 将下载的数据回调给<code>AVAssetResourceLoader</code> ，最终实现自定义下载并播放的功能。</p>
<h2 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h2><p><code>AVPlayer</code> 是用于管理和控制媒体资源的播放的控制器对象。它提供了控制播放器的传输行为接口。例如播放，暂停，更改播放速度，以及在媒体时间线内的各种时间点。可以使用<code>AVPlayer</code> 播放本地和远程的基于文件的媒体，例如 QuickTime 视频和 MP3 音频文件，以及使用 HTTP Live Streaming 提供的视听媒体。</p>
<h3 id="AVPlayer-常用属性与方法"><a href="#AVPlayer-常用属性与方法" class="headerlink" title="AVPlayer 常用属性与方法"></a>AVPlayer 常用属性与方法</h3><p><code>AVPlayer</code> 是一个状态不断变化的动态对象，在播放期间的属性改变通知都是在同一个队列中进行，默认情况下是在主线程队列。因此只要是在主线程上注册和注销KVO，就可以放心使用而不用担心线程同步问题。</p>
<h4 id="1-初始化方法"><a href="#1-初始化方法" class="headerlink" title="1.初始化方法"></a>1.初始化方法</h4><p>可以通过 <code>URL</code> 或者 <code>AVPlayerItem</code> 资源实例化 <code>AVPlayer</code> ，可以是本地资源也可以是网络资源。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(url <span class="type">URL</span>: <span class="type">URL</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(playerItem item: <span class="type">AVPlayerItem</span>?)</div></pre></td></tr></table></figure>
<p>如果是通过 <code>init(url:)</code> 方法实例化，那么内部会隐式创建一个播放项（<code>AVPlayerItem</code> 类）作为 <code>currentPlayItem</code> 属性。 </p>
<p><code>AVAsset</code> 只是一个关于媒体资源静态方面属性的模型，例如总时长、创建时间。本身并不适合直接通过 <code>AVPlayer</code> 直接播放。如果要播放 <code>AVAsset</code> 资源需要创建一个 <code>AVPlayerItem</code> 实例，该对象可以提供 <code>AVPlayer</code> 播放时所需要的时间、画面等。</p>
<h4 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2.基本属性"></a>2.基本属性</h4><ul>
<li><strong>status</strong> (key value observable)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPlayerStatus</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> unknown     <span class="comment">// 表示未知的播放器状态，因为还没有尝试加载新的媒体资源</span></div><div class="line">    <span class="keyword">case</span> readyToPlay <span class="comment">// 表示播放器已经准备好播放 AVPlayerItem 资源</span></div><div class="line">    <span class="keyword">case</span> failed      <span class="comment">// 表示播放器因播放错误而无法播放 AVPlayerItem 资源</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// key value observable</span></div><div class="line">open <span class="keyword">var</span> status: <span class="type">AVPlayerStatus</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p><code>status</code> 表示播放器是否可以播放。当属性值为 <code>.failed</code> 说明播放器不能再用于播放，并且需要重新设置资源。可以使用KVO监听该属性变化。</p>
<p>此外 <code>AVPlayer</code> 的 <code>currentItem</code> 也提供一个相对应的状态，其类型为 <code>AVPlayerItemStatus</code> 。</p>
<ul>
<li><strong>error</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> error: <span class="type">Error</span>? &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>当 <code>status</code> 状态为 <code>falied</code> 时，可以通过该属性获取播放失败的原因。如果 <code>status</code> 状态不是 <code>falied</code> 则该属性的值为 <code>nil</code> 。</p>
<p>此外 <code>AVPlayer</code> 的 <code>currentItem</code> 也提供一个相对应的错误描述属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当 AVPlayerItemStatus 为 failed 状态才会有值，其余情况为 nil</span></div><div class="line">open <span class="keyword">var</span> error: <span class="type">Error</span>? &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<h4 id="3-播放控制"><a href="#3-播放控制" class="headerlink" title="3.播放控制"></a>3.播放控制</h4><ul>
<li><strong>rate</strong> (key value observable)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> rate: <span class="type">Float</span></div></pre></td></tr></table></figure>
<p><code>rate</code> 表示播放器的播放速率。</p>
<p>当设置为 0.0 时会暂停播放，同时会使 <code>timeControlStatus</code> （iOS 10 开始提供该属性）状态变更为 <code>paused</code> 状态。设置为非0值时，如果已缓冲足够的媒体数据，会使 <code>timeControlStatus</code> 状态变更为 <code>playing</code> 。如果还没缓冲足够的数据，状态则变更为  <code>waitingToPlayAtSpecifiedRate</code> 。</p>
<p>当调用 <code>play()</code> 方法并且可播放时 <code>rate</code> 将被设置为1.0，调用 <code>pause()</code> 将被设置为0.0。</p>
<p>此外当全局播放状态要求暂停播放时 <code>rate</code> 将被设置为0.0。例如接收到 <code>AVAudioSession</code> 的中断通知 <code>AVAudioSessionInterruption</code> ，或者播放缓冲区为空并且<code>automaticallyWaitsToMinimizeStalling</code> 为 <code>false</code> 时。</p>
<p>关于播放速率的更多信息可以查看 <strong>AVAudioProcessingSettings.h</strong> 。</p>
<ul>
<li><strong>play()</strong> and <strong>pause()</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">pause</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>播放与暂停，相当于将 <code>rate</code> 设置为 1.0 或 0.0。</p>
<ul>
<li><strong>timeControlStatus</strong> (key value observable)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPlayerTimeControlStatus</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> paused</div><div class="line">    <span class="keyword">case</span> waitingToPlayAtSpecifiedRate</div><div class="line">    <span class="keyword">case</span> playing</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</div><div class="line"><span class="comment">// key value observable</span></div><div class="line">open <span class="keyword">var</span> timeControlStatus: <span class="type">AVPlayerTimeControlStatus</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p><code>timeControlStatus</code> 用于表示资源播放状态，当 <code>automaticallyWaitsToMinimizeStalling</code> 为 <code>true</code> 时该属性才有效。</p>
<p>三种状态的表示情况：</p>
<ul>
<li>当处于 <code>paused</code> 状态时将会无期限暂停，直到调用 <code>play()</code> 方法或者设置 <code>rate</code> 、<code>playImmediately(atRate:)</code> 为非0值并且已经缓冲足够的数据才会继续播放。</li>
<li>当处于 <code>playing</code> 状态时，修改 <code>rate</code> 将会立即生效，当可播放的媒体数据不足时将会变更为 <code>waitingToPlayAtSpecifiedRate</code> 状态。</li>
<li>当处于 <code>waitingToPlayAtSpecifiedRate</code> 状态时，当前的<code>rate</code> 属性值并不是有效的，而是表示开始播放或恢复播放的速率。在等待缓冲时，可以尝试通过调用 <code>playImmediately(atRate:)</code> 开始播放任何可用的媒体数据。</li>
</ul>
<p>在 <code>AVPlayer</code> 内部会根据播放状态自动切换：</p>
<ul>
<li>当状态为 <code>playing</code> 并且播放缓冲区为空时，会切换为 <code>waitingToPlayAtSpecifiedRate</code> 状态。</li>
<li>当状态为 <code>paused</code> 并且调用 <code>play()</code> 方法或设置 <code>rate</code> 为非0值时，会切换为 <code>waitingToPlayAtSpecifiedRate</code> 状态。</li>
<li>当 <code>AVPlayer</code> 没有可播放的资源选项时，也即 <code>currentItem</code> 为 <code>nil</code> 时，将会设置为 <code>waitingToPlayAtSpecifiedRate</code> 状态。</li>
<li>设置 <code>rate</code> 为0.0，或者调用 <code>pause()</code> 方法，<code>timeControlStatus</code> 将被设置为 <code>paused</code> 状态。</li>
<li>设置 <code>rate</code> 为非0值，或者调用 <code>play()</code> 方法并且已缓冲足够媒体数据时，将会设置为 <code>playing</code> 状态。</li>
</ul>
<p>由于前三种情况将状态切换为 <code>waitingToPlayAtSpecifiedRate</code> 时，可以通过 <code>reasonForWaitingToPlay</code> 属性（iOS10开始提供）获取播放器等待的原因，分别对应三个字符串常量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</div><div class="line"><span class="comment">// 当设置 automaticallyWaitsToMinimizeStalling 为 false 导致 timeControlStatus 无法变为 waitingToPlayAtSpecifiedRate 也是展示该原因</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">let</span> <span class="type">AVPlayerWaitingToMinimizeStallsReason</span>: <span class="type">String</span></div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="keyword">let</span> <span class="type">AVPlayerWaitingWhileEvaluatingBufferingRateReason</span>: <span class="type">String</span></div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="keyword">let</span> <span class="type">AVPlayerWaitingWithNoItemToPlayReason</span>: <span class="type">String</span></div></pre></td></tr></table></figure>
<p>其他状态下 <code>reasonForWaitingToPlay</code> 属性为 <code>nil</code>。</p>
<h4 id="4-播放资源控制"><a href="#4-播放资源控制" class="headerlink" title="4.播放资源控制"></a>4.播放资源控制</h4><ul>
<li><strong>currentItem</strong> </li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">var</span> currentItem: <span class="type">AVPlayerItem</span>? &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>表示当前播放的资源</p>
<ul>
<li><strong>replaceCurrentItem(with:)</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">replaceCurrentItem</span><span class="params">(with item: AVPlayerItem?)</span></span></div></pre></td></tr></table></figure>
<p><code>AVPlayer</code> 一次只能播放一个媒体资源，可以通过这个方法替换播放器的资源。但在 iOS 10 上使用该方法替换播放资源会有点卡顿，因此还是建议直接创建一个新的播放器。</p>
<p>此外 <code>AVFoundation</code> 框架还提供了 <code>AVPlayer</code> 的一个子类——<code>AVQueuePlayer</code> 。可以用于创建和管理需要顺序播放的资源媒体队列。</p>
<ul>
<li><strong>actionAtItemEnd</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPlayerActionAtItemEnd</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">advance</span></div><div class="line">    <span class="keyword">case</span> pause</div><div class="line">    <span class="keyword">case</span> <span class="keyword">none</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">open <span class="keyword">var</span> actionAtItemEnd: <span class="type">AVPlayerActionAtItemEnd</span></div></pre></td></tr></table></figure>
<p>表示播放项目到达结束时间时该执行的动作。</p>
<h4 id="5-播放时间控制"><a href="#5-播放时间控制" class="headerlink" title="5.播放时间控制"></a>5.播放时间控制</h4><ul>
<li><strong>currentTime</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">currentTime</span><span class="params">()</span></span> -&gt; <span class="type">CMTime</span></div></pre></td></tr></table></figure>
<p>表示当前播放的时长，由 <code>currentItem</code> 提供，该属性不可以通过KVO监听，如果需要监听播放时长可以通过 <code>addPeriodicTimeObserver(forInterval:queue:using:)</code> 实现。</p>
<ul>
<li>寻找当前播放选项的指定时间</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to date: Date)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to date: Date, completionHandler: @escaping <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to time: CMTime)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime)</span></span></div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to time: CMTime, completionHandler: @escaping <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</div><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">seek</span><span class="params">(to time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: @escaping <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)</div></pre></td></tr></table></figure>
<p>可以通过这些方法设置在资源的指定时间点开始播放，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newValue = <span class="type">Double</span>(slider.value)</div><div class="line"><span class="keyword">let</span> newTime = <span class="type">CMTimeMakeWithSeconds</span>(newValue, <span class="number">1</span>)</div><div class="line">player.seek(to: newTime, toleranceBefore: kCMTimeZero, toleranceAfter: kCMTimeZero)</div></pre></td></tr></table></figure>
<p><code>completionHandler</code> 中，任何尚在进行中的任何寻求请求的完成处理程序将立即被调用，其中完成的参数设置为<code>false</code>。 如果新的请求完成而不被另一个寻求请求或任何其他操作中断，则将使用已完成的参数设置为<code>true</code>来调用指定的安装者。</p>
<p>The completion handler for any prior seek request that is still in process will be invoked immediately with the finished parameter  set to NO. If the new request completes without being interrupted by another seek request or by any other operation the specified  andler will be invoked with the finished parameter set to YES. </p>
<h4 id="6-播放时间状态观察"><a href="#6-播放时间状态观察" class="headerlink" title="6.播放时间状态观察"></a>6.播放时间状态观察</h4><p>通过KVO可以观察一些状态属性的变化，但不适合持续变化的状态，例如当前播放时间等。<code>AVPlayer</code> 提供两个方法在时长变化时回调外部进行处理以及更新用户界面。</p>
<ul>
<li><strong>addPeriodicTimeObserver(forInterval:queue:using:)</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addPeriodicTimeObserver</span><span class="params">(forInterval interval: CMTime, queue: DispatchQueue?, using block: @escaping <span class="params">(CMTime)</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">Any</span></div></pre></td></tr></table></figure>
<p>该方法将会以指定的时间间隔周期性的调用 block，当播放时间跳动，或者播放开始以及结束时 block也会被调用。该方法会返回一个观察者对象，这个对象可供 <code>removeTimeObserver(_:)</code> 方法使用。因此必须保留这个观察对象以便移除观察者。</p>
<p>queue 参数必须使用串行队列，当传入空时将使用主队列。如果传入并发队列将会导致方法异常。</p>
<ul>
<li><strong>addBoundaryTimeObserver(forTimes:queue:using:)</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">addBoundaryTimeObserver</span><span class="params">(forTimes times: [NSValue], queue: DispatchQueue?, using block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">Any</span></div></pre></td></tr></table></figure>
<p>与 <code>addPeriodicTimeObserver(forInterval:queue:using:)</code> 类似，只不过 forTimes 参数需要传入的是播放期间的指定时间点（例如指定播放到3秒时回调）。</p>
<ul>
<li><strong>removeTimeObserver(_:)</strong> </li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">removeTimeObserver</span><span class="params">(<span class="number">_</span> observer: Any)</span></span></div></pre></td></tr></table></figure>
<p>用于移除时间观察者。添加时间观察者和移除时间观察者的方法必须成对出现，否则会出现异常。</p>
<h2 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h2><p><code>AVPlayer</code> 和 <code>AVPlayerItem</code> 并不直接提供展示视频的用户界面。如果需要在屏幕上显示视频可以使用 <code>AVKit</code> 中的 <code>AVPlayerViewController</code> 类（macOS 可以使用 <code>AVPlayerView</code> 类），或者使用 <code>AVPlayerLayer</code> 自定义展示界面。</p>
<p><code>AVPlayerLayer</code> 继承自 <code>CALayer</code> ，与 <code>AVPlayerViewController</code> 和 <code>AVPlayerView</code> 不同，该图层仅展示可视内容，不额外提供任何播放控件。因此需要手动添加播放控制的控件，虽然比较麻烦但也极具灵活性。</p>
<p>需要展示视频内容时，只需要设置 <code>player</code> 属性即可，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> player = <span class="type">AVPlayer</span>(url: url)</div><div class="line"><span class="keyword">let</span> playerLayer = <span class="type">AVPlayerLayer</span>(player: player)</div><div class="line">view.layer.addSublayer(playerLayer)</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">let</span> player = <span class="type">AVPlayer</span>(url: url)</div><div class="line"><span class="keyword">self</span>.playerLayer.player = player</div></pre></td></tr></table></figure>
<p>如果需要适配展示内容的显示范围，可以通过以下两个属性控制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 视频在 AVPlayerLayer 中的显示方法，包括：</span></div><div class="line"><span class="comment">// AVLayerVideoGravityResizeAspect, AVLayerVideoGravityResizeAspectFill, AVLayerVideoGravityResize</span></div><div class="line"><span class="comment">// 默认为 AVLayerVideoGravityResizeAspect</span></div><div class="line">open <span class="keyword">var</span> videoGravity: <span class="type">String</span></div><div class="line"></div><div class="line"><span class="comment">// 视频图像当前的位置和大小</span></div><div class="line">open <span class="keyword">var</span> videoRect: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>除了 <code>AVPlayerLayer</code> 提供的视觉内容外，还可以使用 <code>AVSynchronizedLayer</code> 向播放器的时序同步呈现动画内容。 这是一个特殊的 Core Animation CALayer 子类，用于将当前播放器的时序赋予它的图层子树。 可以使用 <code>AVSynchronizedLayer</code> 在Core Animation中构建自定义效果，例如动画或视频转换，并使其与播放器当前的 <code>AVPlayerItem</code> 同步播放。</p>
<h2 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h2><p><code>AVAsset</code> 及其子类负责提供媒体资源静态方面的数据，而 <code>AVPlayerItem</code> 将其组装为可供 <code>AVPlayer</code> 播放的动态资源，并提供可观察（key value observable）的状态。键值观察的所有播放状态改变的通知都由关联的 <code>AVPlayer</code> 的同一调度队列中发送，这个调度队列默认为 主线程队列。</p>
<h3 id="AVPlayerItem-常用属性与方法"><a href="#AVPlayerItem-常用属性与方法" class="headerlink" title="AVPlayerItem 常用属性与方法"></a>AVPlayerItem 常用属性与方法</h3><p>对比 <code>AVPlayer</code> 就会发现这两个类有不少属性都非常相似，其实这正式因为 <code>AVPlayer</code> 需要 <code>AVPlayerItem</code> 提供可播放动态资源数据所导致的，<code>AVPlayer</code> 不少属性的状态变化都是通过 <code>AVPlayerItem</code> 的属性变化来传递。</p>
<h4 id="1-初始化方法-1"><a href="#1-初始化方法-1" class="headerlink" title="1.初始化方法"></a>1.初始化方法</h4><p>可以通过 <code>URL</code> 或者 <code>AVAsset</code> 实例化 <code>AVPlayerItem</code> ，可以是本地资源也可以是网络资源。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(url <span class="type">URL</span>: <span class="type">URL</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(asset: <span class="type">AVAsset</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(asset: <span class="type">AVAsset</span>, automaticallyLoadedAssetKeys: [<span class="type">String</span>]?)</div></pre></td></tr></table></figure>
<p><code>init(asset:automaticallyLoadedAssetKeys:)</code> 的 <code>automaticallyLoadedAssetKeys</code> 参数表示 <code>AVAsset</code> 头文件所定义的属性的 key。在 <code>status</code> 变为 <code>AVPlayerItemStatusReadyToPlay</code> 之前，底层的 <code>AVAsset</code> 将自动加载参数所提供的所有 key 对应的属性值 </p>
<p><code>init(url:)</code> 相当于通过 <code>AVAsset(url:)</code> 创建一个 <code>AVAsset</code> 对象并调用 <code>init(asset:)</code> 初始化方法。</p>
<p><code>init(asset:)</code> 相当于调用 <code>init(asset:automaticallyLoadedAssetKeys:)</code>初始化方法，并将 <code>[&quot;duration&quot;]</code> 作为自动加载的属性传入到 <code>automaticallyLoadedAssetKeys</code> 参数中</p>
<h4 id="2-基本属性-1"><a href="#2-基本属性-1" class="headerlink" title="2.基本属性"></a>2.基本属性</h4><ul>
<li><strong>status</strong> (key value observable)，<strong>error</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AVPlayerItemStatus</span> : <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> unknown     <span class="comment">// 表示未知的播放选项状态，因为还没有尝试加载新的媒体资源</span></div><div class="line">    <span class="keyword">case</span> readyToPlay <span class="comment">// 表示播放选项已经准备好可播放资源</span></div><div class="line">    <span class="keyword">case</span> failed      <span class="comment">// 表示播放选项的资源加载错误而导致无法播放</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// key value observable</span></div><div class="line">open <span class="keyword">var</span> status: <span class="type">AVPlayerStatus</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">open <span class="keyword">var</span> error: <span class="type">Error</span>? &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>参照上面 <code>AVPlayer</code> 的 <code>status</code> 和 <code>error</code> 属性，几乎一模一样。</p>
<h4 id="4-播放时间控制"><a href="#4-播放时间控制" class="headerlink" title="4.播放时间控制"></a>4.播放时间控制</h4><p>任何尚在进行中的任何寻求请求的完成处理程序将立即被调用，其中完成的参数设置为NO。 如果新的请求完成而不被另一个查询请求或任何其他操作中断，则将使用完成的参数设置为YES来调用指定的完成处理程序。 如果查找时间超出了seekableTimeRanges属性所示的可寻求时间范围，则seek请求将被取消，并且完成处理程序将被调用，其中完成的参数设置为NO。</p>
<p>The completion handler for any prior seek request that is still in process will be invoked immediately with the finished parameter  set to NO. If the new request completes without being interrupted by another seek request or by any other operation the specified  completion handler will be invoked with the finished parameter set to YES.  If the seek time is outside of seekable time ranges as indicated by seekableTimeRanges property, the seek request will be cancelled and the completion handler will be invoked with the finished parameter set to NO.</p>
<h3 id="AVPlayerItem-通知"><a href="#AVPlayerItem-通知" class="headerlink" title="AVPlayerItem 通知"></a>AVPlayerItem 通知</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/04/15/AVFAudio-录音/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/15/AVFAudio-录音/" itemprop="url">
                  AVFAudio-录音
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-15T12:20:39+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AVFAudio"><a href="#AVFAudio" class="headerlink" title="AVFAudio"></a>AVFAudio</h2><p><code>AVFAudio</code> 框架除了提供音频播放器类 <code>AVAudioPlayer</code> 外，还提供一个处理录音的类 <code>AVAudioRecorder</code> 。</p>
<p><a href="https://github.com/arKenLee/MediaDemo" target="_blank" rel="external">Demo</a></p>
<h2 id="AVAudioRecorder"><a href="#AVAudioRecorder" class="headerlink" title="AVAudioRecorder"></a>AVAudioRecorder</h2><p>使用 <code>AVAudioRecorder</code> 类可以实现录音功能，支持设置比特率、采样率、转换质量等。录制音频的来源可以是内置麦克风、耳机麦克风等设备。</p>
<h3 id="设置-AVAudioSession-与询问权限"><a href="#设置-AVAudioSession-与询问权限" class="headerlink" title="设置 AVAudioSession 与询问权限"></a>设置 AVAudioSession 与询问权限</h3><p>在使用 <code>AVAudioRecorder</code> 之前需要设置 <code>AVAudioSession</code> 的类别为<code>AVAudioSessionCategoryRecord</code> 或者<code>AVAudioSessionCategoryPlayAndRecord</code> ，并且还要取得麦克风使用的权限。</p>
<p>需要特别注意的是，如果录音文件流没有关闭，此时设置 <code>AVAudioSession</code> 的 <code>active</code> 为 <code>false</code> 在 iOS8及以上的版本会直接Crash。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置类别</span></div><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div><div class="line">        </div><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">9</span>, *) &#123;</div><div class="line">    <span class="keyword">if</span> !audioSession.availableCategories.<span class="built_in">contains</span>(<span class="type">AVAudioSessionCategoryRecord</span>) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"当前设备不支持录音功能"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> audioSession.category != <span class="type">AVAudioSessionCategoryRecord</span> &#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">try</span> audioSession.setCategory(<span class="type">AVAudioSessionCategoryRecord</span>)</div><div class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"设置录音类别失败: <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 询问权限</span></div><div class="line">audioSession.requestRecordPermission &#123; (granted: <span class="type">Bool</span>) <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> (!granted) &#123;</div><div class="line">    	<span class="built_in">print</span>(<span class="string">"用户拒绝授权使用麦克风"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在播放录音文件时，如果类别为 AVAudioSessionCategoryPlayAndRecord，播放的声音将会很小声，改为使用 AVAudioSessionCategoryRecord 类别即可。</p>
<p>关于 AVAudioSession 的详细参数设置，可以参考上一篇文章 <a href="https://arkenlee.github.io/2017/04/04/AVFAudio-iOS音频播放/">AVFAudio-iOS音频播放</a>。</p>
</blockquote>
<h3 id="初始化和配置AVAudioRecorder"><a href="#初始化和配置AVAudioRecorder" class="headerlink" title="初始化和配置AVAudioRecorder"></a>初始化和配置AVAudioRecorder</h3><p>初始化 <code>AVAudioRecorder</code> 需要传入保存录音文件的本地路径，如果路径文件存在那么在调用<code>prepareToRecord()</code> 方法时会覆盖原文件。另外还需要一个参数设置的字典或者一种格式（AVAudioFormat）。</p>
<h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><p>可设置参数的字段可以在 <strong>AVAudioSettings.h</strong> 头文件中查看。其中包括设置录音格式（AVFormatIDKey）、声道数（AVNumberOfChannelsKey）、采样率（AVSampleRateKey）等。</p>
<p>录音编码格式可在 <strong>CoreAudioTypes.h</strong> 头文件中查看，头文件中列出了很多种格式，实际上苹果支持的格式不多。当录音文件需要在多端播放时，只能使用共同的编码格式，例如：aac、mp3、amr等格式。</p>
<p>需要录制mp3时不能直接 <code>kAudioFormatMPEGLayer3</code> ，只能先录制其他格式的音频再通过其他途径转为 mp3 格式。例如录制一段 AAC 音频然后通过 <a href="https://sourceforge.net/projects/lame/files/lame/3.99/" target="_blank" rel="external">lame</a> 转为 mp3 格式的音频文件。</p>
<blockquote>
<p>将 lame 打包成库的教程：<a href="http://blog.csdn.net/cx_wzp/article/details/50911261" target="_blank" rel="external">http://blog.csdn.net/cx_wzp/article/details/50911261</a></p>
</blockquote>
<p>其他参数设置：</p>
<p>a) AVSampleRateKey：采样率，默认为44100</p>
<p>b) AVNumberOfChannelsKey：声道数</p>
<p>c) AVEncoderAudioQualityKey：音频编码质量，默认为<code>AVAudioQualityMin</code></p>
<p>d) AVEncoderBitRateKey：音频编码比特率，单位为Kbps<br>​    16Kbps = 电话音质<br>　　 24Kbps = 增加电话音质、短波广播、长波广播、欧洲制式中波广播<br>　　 40Kbps = 美国制式中波广播<br>　　 56Kbps = 话音<br>　　 64Kbps = 增加话音（手机铃声最佳比特率设定值、手机单声道MP3播放器最佳设定值）<br>　　 112Kbps = FM调频立体声广播<br>　　 128Kbps = 磁带（手机立体声MP3播放器最佳设定值、低档MP3播放器最佳设定值）<br>　　 160Kbps = HIFI高保真（中高档MP3播放器最佳设定值）<br>　　 192Kbps = CD（高档MP3播放器最佳设定值）<br>　　 256Kbps = Studio音乐工作室（音乐发烧友适用）</p>
<h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h4><p>a) isRecording：是否正在录音，只读属性；</p>
<p>b) url：录音文件URL，只读属性；</p>
<p>c) settings：录音文件配置，只读属性；</p>
<p>d) delegate：代理；</p>
<p>e) currentTime：录音时长，仅在录音状态有效，只读属性</p>
<p>f) deviceCurrentTime：输入设备时长，配合 <code>record(atTime:)</code> 方法使用，只读属性</p>
<p>g) isMeteringEnabled：是否使用仪表数据，默认为 <code>false</code>。如果需要获取录音的分贝大小，需要设置为<code>true</code>。</p>
<p>h) channelAssignments：当前录音的通道，仅iOS有该属性。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> filename = <span class="string">"record.m4a"</span></div><div class="line"><span class="keyword">let</span> location = <span class="type">URL</span>(fileURLWithPath: <span class="type">NSTemporaryDirectory</span>()).appendingPathComponent(filename)</div><div class="line"></div><div class="line"><span class="comment">// Linear PCM 数据是最原始的无损音频数据，但文件体积过大是明显的缺点</span></div><div class="line"><span class="comment">// 44.1kHz，16bit，双音道的音频文件，每分钟的数据量约为 44.1*16*2*60kbit=10.3M</span></div><div class="line"><span class="keyword">let</span> settings: [<span class="type">String</span>: <span class="type">Any</span>] = [</div><div class="line">    <span class="type">AVFormatIDKey</span>: kAudioFormatLinearPCM, <span class="comment">// 录音格式</span></div><div class="line">    <span class="type">AVSampleRateKey</span>: <span class="number">11025.0</span>,  <span class="comment">// 采样率，如果不设置默认为 44100</span></div><div class="line">    <span class="type">AVNumberOfChannelsKey</span>: <span class="number">1</span>,  <span class="comment">// 单声道</span></div><div class="line">    </div><div class="line"><span class="comment">//    AVEncoderBitRateKey: 128,  // 比特率值</span></div><div class="line"><span class="comment">//    AVEncoderAudioQualityKey: AVAudioQualityMin, // 编码质量</span></div><div class="line"></div><div class="line"><span class="comment">//    AVLinearPCMBitDepthKey: 8,       // 位深度，Linear PCM 属性，可取的值包括：8, 16, 24, 32。默认为16位</span></div><div class="line"><span class="comment">//    AVLinearPCMIsBigEndianKey: true, // Linear PCM 属性，如果不设置默认 false，即“小端字节序”</span></div><div class="line"><span class="comment">//    AVLinearPCMIsFloatKey: true,     // Linear PCM 属性，如果不设置默认 true</span></div><div class="line"><span class="comment">//    ...</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> recorder = <span class="keyword">try</span> <span class="type">AVAudioRecorder</span>(url: path, settings: audioSetting)</div><div class="line">    recorder.isMeteringEnabled = <span class="literal">true</span></div><div class="line">    recorder.delegate = <span class="keyword">self</span></div><div class="line">    <span class="keyword">self</span>.audioRecorder = recorder</div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"初始化录音失败: <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="录音控制方法"><a href="#录音控制方法" class="headerlink" title="录音控制方法"></a>录音控制方法</h3><h4 id="1-准备录音"><a href="#1-准备录音" class="headerlink" title="1.准备录音"></a>1.准备录音</h4><p>在 <code>AVAudioRecorder</code> 实例第一次录音前，需要先调用一次 <code>prepareToRecord()</code> 方法，此时会创建一个录音文件并准备开始录音。如果设备不支持录音，或者没有麦克风权限，或者 <code>AVAudioSession</code> 设置的类别不支持录音，该方法会返回 <code>false</code> 。</p>
<h4 id="2-开始录音"><a href="#2-开始录音" class="headerlink" title="2.开始录音"></a>2.开始录音</h4><p>开始录音有4个方法：</p>
<p>  a) record()，调用该方法会立即开始录音</p>
<p>  b) record(atTime:)，需要配合<code>deviceCurrentTime</code>属性使用，表示在一段时间后开始录音</p>
<p>  c) record(forDuration:)，调用该方法会立即开始录音，并且可以限定录音最长时长</p>
<p>  d) record(atTime:, forDuration:)，同2和3</p>
<h4 id="3-暂停录音和停止录音"><a href="#3-暂停录音和停止录音" class="headerlink" title="3.暂停录音和停止录音"></a>3.暂停录音和停止录音</h4><p>调用 <code>pause()</code> 方法和 <code>stop()</code> 方法可以分别暂停和停止录音。调用暂停方法可以通过调用4个record方法恢复录音，而一旦调用stop方法就不能再恢复录音了。</p>
<h4 id="4-获取录音分贝值"><a href="#4-获取录音分贝值" class="headerlink" title="4.获取录音分贝值"></a>4.获取录音分贝值</h4><p>获取录音分贝必须要将 <code>isMeteringEnabled</code> 属性设置为true，并且在获取分贝值前需要调用 <code>updateMeters()</code> 方法刷新数值。然后通过 <code>peakPower(forChannel:)</code> 和 <code>averagePower(forChannel)</code>  方法可以获取指定通道的分贝峰值和平均值。</p>
<h4 id="5-删除录音文件"><a href="#5-删除录音文件" class="headerlink" title="5.删除录音文件"></a>5.删除录音文件</h4><p>调用 <code>deleteRecording()</code> 方法可以删除录音文件，但只要在停止录音状态才能删除。在删除前必须先判断文件是否存在，如果文件不存在时调用该方法会直接Crash。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始录音</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startRecord</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.audioRecorder.prepareToRecord() &#123;</div><div class="line">        <span class="comment">// 立即录音</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.audioRecorder.record()) &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"开始录音"</span>)</div><div class="line">            <span class="keyword">self</span>.tiemr = <span class="type">Timer</span>(timeInterval: <span class="number">0.1</span>, target: <span class="keyword">self</span>, selector: #selector(updateRecordUI), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</div><div class="line">            <span class="type">RunLoop</span>.current.add(<span class="keyword">self</span>.tiemr, forMode: .commonModes)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"开始录音失败"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 5秒后录音</span></div><div class="line"><span class="comment">//        let deviceCurrentTime = self.audioRecorder.deviceCurrentTime</span></div><div class="line"><span class="comment">//        let fireTime = deviceCurrentTime + 5</span></div><div class="line"><span class="comment">//        if (self.audioRecorder.record(atTime: fireTime)) &#123;</span></div><div class="line"><span class="comment">//            print("5秒后开始录音")</span></div><div class="line"><span class="comment">//        &#125; else &#123;</span></div><div class="line"><span class="comment">//            print("开始录音失败")</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        </div><div class="line">        <span class="comment">// 最多录制1分钟</span></div><div class="line"><span class="comment">//        let recordDurationLimit: TimeInterval = 60</span></div><div class="line"><span class="comment">//        if (self.audioRecorder.record(forDuration: recordDurationLimit)) &#123;</span></div><div class="line"><span class="comment">//            print("开始录音，最多录制1分钟")</span></div><div class="line"><span class="comment">//        &#125; else &#123;</span></div><div class="line"><span class="comment">//            print("开始录音失败")</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        </div><div class="line">        <span class="comment">// 5秒后录音，最多录制1分钟</span></div><div class="line"><span class="comment">//        if (self.audioRecorder.record(atTime: fireTime, forDuration: recordDurationLimit)) &#123;</span></div><div class="line"><span class="comment">//            print("5秒后录音，最多录制1分钟")</span></div><div class="line"><span class="comment">//        &#125; else &#123;</span></div><div class="line"><span class="comment">//            print("开始录音失败")</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"录音准备失败"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 暂停录音</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pauseRecord</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.audioRecorder.pause()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 停止录音</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopRecord</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.audioRecorder.stop()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除录音文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRecordFile</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.audioRecorder.deleteRecording()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 刷新UI</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRecordUI</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 在使用分贝属性前需要刷新仪表值</span></div><div class="line">    <span class="keyword">self</span>.audioRecorder.updateMeters()</div><div class="line">    <span class="keyword">let</span> peakPower = audioRecorder.peakPower(forChannel: <span class="number">0</span>)</div><div class="line">    <span class="keyword">let</span> averagePower = audioRecorder.averagePower(forChannel: <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h3><p>与音频播放类似，<code>AVAudioRecorderDelegate</code> 也有两个方法，分别是获取录音结束和录音编码错误的代理方法。</p>
<p>在调用 <code>stop()</code> 方法后，就会触发 <code>audioRecorderDidFinishRecording(_:successfully:)</code> 代理方法。比如在录音停止后用户可以试听录音文件，此时就可以通过这个代理方法获取停止录音时机并播放。</p>
<p>当录音编码错误或磁盘空间不足时，会触发 <code>audioRecorderEncodeErrorDidOccur(_:error:)</code> 代理方法，此时可以执行提示用户录音错误等操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">audioRecorderDidFinishRecording</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder, successfully flag: Bool)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"录音完毕，可以播放"</span>)</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">audioRecorderEncodeErrorDidOccur</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder, error: Error?)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"录音编码失败, player: <span class="subst">\(recorder)</span>, error: <span class="subst">\(error?.localizedDescription ?? "未知错误")</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="录音文件拼接"><a href="#录音文件拼接" class="headerlink" title="录音文件拼接"></a>录音文件拼接</h3><p>录音文件在播放状态和暂停状态时是不可以播放的，只有在停止状态才可播放，而一旦录音停止就无法恢复录音。</p>
<p>如果需要实现在录制一段音频后，点击播放按钮播放录音文件，点击录音按钮继续录音的功能，就需要对录音文件进行拼接。一种做法是每录制一段音频后拼接到上一段录音文件中。</p>
<p>如果录音文件的目标格式已经转换为mp3格式，那么直接通过<code>NSFileHandle</code> 通过文件偏移量和写入操作即可完成录音拼接。因为mp3可以是无头的音频格式，将音频数据段拼接在一起就可以形成完整的mp3音频文件。如果录音文件的目标格式仍然是 AAC 格式，那么可以使用 <code>AVMutableComposition</code> 和 <code>AVAssetExportSession</code> 实现拼接操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pieceAudio</span><span class="params">(url1: URL, audio2 url2: URL, outputURL: URL, completion: <span class="params">(<span class="params">(Bool)</span></span></span></span>-&gt;<span class="type">Void</span>)?) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> audio1Exists = fileManager.fileExists(atPath: url1.path)</div><div class="line">    <span class="keyword">let</span> audio2Exists = fileManager.fileExists(atPath: url2.path)</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> audio1Exists || audio2Exists <span class="keyword">else</span> &#123;</div><div class="line">        completion?(<span class="literal">false</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> composition = <span class="type">AVMutableComposition</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> audioAsset1 = <span class="type">AVURLAsset</span>(url: url1)</div><div class="line">    <span class="keyword">let</span> audioAsset2 = <span class="type">AVURLAsset</span>(url: url2)</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> timePosition = kCMTimeZero</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> audioAssetTrack1 = audioAsset1.tracks(withMediaType: <span class="type">AVMediaTypeAudio</span>).first &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> timeRange = <span class="type">CMTimeRangeMake</span>(kCMTimeZero, audioAsset1.duration)</div><div class="line">        <span class="keyword">let</span> track = composition.addMutableTrack(withMediaType: <span class="type">AVMediaTypeAudio</span>, preferredTrackID: <span class="number">0</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">try</span> track.insertTimeRange(timeRange, of: audioAssetTrack1, at: timePosition)</div><div class="line">            timePosition = audioAsset1.duration</div><div class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"插入第一个音轨失败: <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> audioAssetTrack2 = audioAsset2.tracks(withMediaType: <span class="type">AVMediaTypeAudio</span>).first &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> timeRange = <span class="type">CMTimeRangeMake</span>(kCMTimeZero, audioAsset2.duration)</div><div class="line">        <span class="keyword">let</span> track = composition.addMutableTrack(withMediaType: <span class="type">AVMediaTypeAudio</span>, preferredTrackID: <span class="number">0</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">try</span> track.insertTimeRange(timeRange, of: audioAssetTrack2, at: timePosition)</div><div class="line">            timePosition = audioAsset2.duration</div><div class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"插入第二个音轨失败: <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> session = <span class="type">AVAssetExportSession</span>(asset: composition, presetName: <span class="type">AVAssetExportPresetAppleM4A</span>) <span class="keyword">else</span> &#123;</div><div class="line">        completion?(<span class="literal">false</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    session.outputURL = outputURL</div><div class="line">    session.outputFileType = <span class="type">AVFileTypeAppleM4A</span></div><div class="line">    </div><div class="line">    session.exportAsynchronously &#123;</div><div class="line">        <span class="keyword">let</span> success = (session.status == .completed)</div><div class="line">        completion?(success)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可以看出 <code>AVAudioRecorder</code> 的接口设计与 <code>AVAudioPlayer</code> 非常相似，对于中断事件和录音设备改变事件都可以通过通知处理（可参照上一篇文章的处理<a href="https://arkenlee.github.io/2017/04/04/AVFAudio-iOS音频播放/">AVFAudio-iOS音频播放</a>）。</p>
<p>然而苹果支持的录音文件格式非常有限，通常需要后期处理，如果需要支持多端播放的录音，就要选择共通的文件封装格式和编码格式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/04/04/AVFAudio-iOS音频播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/AVFAudio-iOS音频播放/" itemprop="url">
                  AVFAudio-iOS音频播放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-04T20:42:13+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>iOS 主要提供了以下几种方式来播放音频：</p>
<ul>
<li>AV Foundation framework</li>
<li>Audio Queue Services</li>
<li>System Sound Services</li>
<li>OpenAL</li>
</ul>
<p>本篇主要介绍使用 <code>AVFoundation</code> 框架中的 <code>AVFAudio</code> 子框架来播放音频</p>
<p><a href="https://github.com/arKenLee/MediaDemo" target="_blank" rel="external">Demo</a></p>
<h2 id="AVFAudio"><a href="#AVFAudio" class="headerlink" title="AVFAudio"></a>AVFAudio</h2><p>在 <code>AVFoundation</code> 中有一个子框架 <code>AVFAudio</code> ，包括了 iOS 音频相关的类以及高级接口。其中最核心的类是 <code>AVAudioSession</code> ，通过 <code>AVAudioSession</code> 来处理App与App之间，App与设备之间的音频交互行为。</p>
<img src="/2017/04/04/AVFAudio-iOS音频播放/aspg_intro.png" alt="aspg_intro.png" title="">
<h3 id="AVAudioSession"><a href="#AVAudioSession" class="headerlink" title="AVAudioSession"></a>AVAudioSession</h3><p><code>AVAudioSession</code> 相当于 App 与 iOS 之间的桥梁，通过它来控制音频相关的行为，通过 <code>AVAudioSession.sharedInstance()</code> 获取单例对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div></pre></td></tr></table></figure>
<p>可处理的事件包括：</p>
<ol>
<li>处理用户拔插耳机、来电等音频中断情况</li>
<li>选择合适的输入和输出设备及路线</li>
<li>响应静音开关事件</li>
<li>集成其他App的音频等等</li>
</ol>
<h3 id="一、激活音频会话-AVAudioSession"><a href="#一、激活音频会话-AVAudioSession" class="headerlink" title="一、激活音频会话 AVAudioSession"></a>一、激活音频会话 AVAudioSession</h3><p>在要处理音频相关的行为（例如播放某个音频）之前需要激活 <code>AVAudioSession</code> ，通过 <code>setActive</code> 或 <code>setActive:with:</code> 方法激活或停用音频会话。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	<span class="keyword">try</span> audioSession.setActive(<span class="literal">true</span>)</div><div class="line">	<span class="comment">// try audioSession.setActive(true, with: [.notifyOthersOnDeactivation])</span></div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">	<span class="built_in">print</span>(<span class="string">"set AVAudioSession active failure with error: <span class="subst">\(error)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果设置选项 <code>notifyOthersOnDeactivation</code> ，在App中断已结束（例如打完电话回到app），并且可能会恢复播放时，通过通知回调给App，仅在 <code>AVAudioSession</code> 停用时有效。如果 <code>AVAudioSession</code> 处于激活状态，App中断结束都可以收到通知。</p>
<p>需要注意的是，这两个设置方法是同步操作，很有可能会阻塞当前线程，因此尽量不要在长时间阻塞的线程去激活音频会话。</p>
<p>从 iOS 8 开始，在运行或暂停音频文件相关的I/O流（例如录音、格式转换等）过程中，如果将音频会话设置为 <code>false</code> App 将会抛出异常，所以在关闭音频会话之前要确保文件流处于关闭状态。</p>
<blockquote>
<p>从 Xcode 8 开始，设置音频会话类别后，系统会打印一些播放日志：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">2017</span>-<span class="number">04</span>-<span class="number">05</span> <span class="number">00</span>:<span class="number">08</span>:<span class="number">00.953226</span>+<span class="number">0800</span> <span class="type">MediaDemo</span>[<span class="number">95980</span>:<span class="number">4515120</span>] [aqme] <span class="number">254</span>: <span class="type">AQDefaultDevice</span> (<span class="number">1</span>): skipping input stream <span class="number">0</span> <span class="number">0</span> <span class="number">0x0</span></div><div class="line">&gt; <span class="number">2017</span>-<span class="number">04</span>-<span class="number">05</span> <span class="number">00</span>:<span class="number">08</span>:<span class="number">02.957846</span>+<span class="number">0800</span> <span class="type">MediaDemo</span>[<span class="number">95980</span>:<span class="number">4515120</span>] [aqme] <span class="number">254</span>: <span class="type">AQDefaultDevice</span> (<span class="number">173</span>): skipping input stream <span class="number">0</span> <span class="number">0</span> <span class="number">0x0</span></div><div class="line">&gt; <span class="number">2017</span>-<span class="number">04</span>-<span class="number">05</span> <span class="number">00</span>:<span class="number">08</span>:<span class="number">04.966414</span>+<span class="number">0800</span> <span class="type">MediaDemo</span>[<span class="number">95980</span>:<span class="number">4515120</span>] [aqme] <span class="number">254</span>: <span class="type">AQDefaultDevice</span> (<span class="number">173</span>): skipping input stream <span class="number">0</span> <span class="number">0</span> <span class="number">0x0</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>可以在 <strong>Scheme</strong> -&gt; <strong>Arguments</strong> -&gt; <strong>Environment Variables</strong> 中添加 <strong>name</strong>： “<em>OS_ACTIVITY_MODE</em> “，<strong>value</strong>为 <em>disable</em> ，系统就不会打印这些额外的信息。</p>
</blockquote>
<h3 id="二、设置类别、模式、选项"><a href="#二、设置类别、模式、选项" class="headerlink" title="二、设置类别、模式、选项"></a>二、设置类别、模式、选项</h3><p>在激活 <code>AVAudioSession</code> 时，还可以进行一些额外的设置，以满足 App 的音频操作需求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	<span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</div><div class="line">		<span class="comment">// iOS 10 以后可以同时设置类别、模式以及选项</span></div><div class="line">		<span class="keyword">try</span> audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayback</span>, mode: <span class="type">AVAudioSessionModeDefault</span>, options: [.mixWithOthers, .duckOthers])</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// iOS 10 以前的接口</span></div><div class="line">		<span class="keyword">try</span> audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayback</span>)</div><div class="line">		<span class="comment">// try audioSession.setCategory(AVAudioSessionCategoryPlayback, with: [.mixWithOthers, .duckOthers])</span></div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">try</span> audioSession.setActive(<span class="literal">true</span>)</div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">     <span class="built_in">print</span>(<span class="string">"error: <span class="subst">\(error)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="七种类别"><a href="#七种类别" class="headerlink" title="七种类别"></a>七种类别</h4><p>可以针对不同的需求选用不同的类别。例如：</p>
<ul>
<li><p>当你希望播放音频时中断其他音频，并且在用户切换“静音”开关或者屏幕锁屏时，播放音频需要中断，那么可以考虑使用<code>AVAudioSessionCategorySoloAmbient</code> 类别；</p>
</li>
<li><p>或者希望可以后台播放音乐，那么可以考虑使用 <code>AVAudioSessionCategoryPlayback</code> ；</p>
</li>
<li><p>或者要做一个音频聊天的App，需要录音的同时能听到对方的讲话，那么可以使用 <code>AVAudioSessionCategoryPlayAndRecord</code> 。</p>
</li>
</ul>
<p>每种类别的特性可以参照下表：</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>说明</th>
<th>是否需要输入</th>
<th>是否需要输出</th>
<th>是否可以混音</th>
<th>可以后台记录或播放</th>
<th>响应静音开关</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVAudioSessionCategoryAmbient</td>
<td>可以同其他音频混音播放</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>AVAudioSessionCategorySoloAmbient</td>
<td>独占播放，会使其他音频静音</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayback</td>
<td>可后台播放，可混音播放</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>AVAudioSessionCategoryRecord</td>
<td>录音模式</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>可以录音也可以播放</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>AVAudioSessionCategoryAudioProcessing</td>
<td>硬件解码音频，不能播放和录音</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>AVAudioSessionCategoryMultiRoute</td>
<td>多种输入输出，例如耳机、USB设备同时播放</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>使用 <code>AVAudioSessionCategoryMultiRoute</code> 的前提输入/输出必须限定为以下几种：<br>Input</p>
<ul>
<li>AVAudioSessionPortUSBAudio</li>
<li>AVAudioSessionPortHeadsetMic</li>
<li>AVAudioSessionPortBuiltInMic</li>
</ul>
<p>Output</p>
<ul>
<li>AVAudioSessionPortUSBAudio</li>
<li>AVAudioSessionPortLineOut</li>
<li>AVAudioSessionPortHeadphones</li>
<li>AVAudioSessionPortHDMI</li>
<li>AVAudioSessionPortBuiltInSpeaker</li>
</ul>
<p>如果不进行额外的设置，默认的音频会话类别是 <code>AVAudioSessionCategorySoloAmbient</code> 。</p>
<p>如果需要支持后台播放，那么除了需要将类别设置为<code>AVAudioSessionCategoryPlayback</code> 外，还需要在 <strong>Background Mode</strong> 中勾选 <strong>Audio, AirPlay and Picture in Picture</strong>。</p>
<img src="/2017/04/04/AVFAudio-iOS音频播放/background_modes.png" alt="Background Mode" title="Background Mode">
<p>设备支持的类别可以通过 <code>availableCategories</code> 属性（iOS 9之后才支持）获取，可以通过这个属性判断待设置的类别设备是否支持，例如不支持音频输入的设备中，<code>AVAudioSessionCategoryRecord</code> 类别不会生效。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div><div class="line"></div><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</div><div class="line">	<span class="keyword">if</span> audioSession.availableCategories.<span class="built_in">contains</span>(<span class="type">AVAudioSessionCategoryPlayAndRecord</span>) &#123;</div><div class="line">		<span class="keyword">try</span>? audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayAndRecord</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">try</span>? audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayback</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取当前类别</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> currentAudioSessionCategory = <span class="type">AVAudioSession</span>.sharedInstance().category</div></pre></td></tr></table></figure>
<h4 id="八种模式"><a href="#八种模式" class="headerlink" title="八种模式"></a>八种模式</h4><p>类别可以定义App的基本音频操作行为，而模式可以细化音频会话，从而进一步定义App的音频操作。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>兼容的类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVAudioSessionModeDefault</td>
<td>All</td>
<td>默认模式，适用于所有类别，并将设备设置为一般用途</td>
</tr>
<tr>
<td>AVAudioSessionModeVoiceChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>用于IP通话（VoIP）App，该模式可以设置选项 <code>AVAudioSessionCategoryOptionAllowBluetooth</code>。音频路由合集会优化语音聊天体验。使用内置麦克风时，系统会自动选择内置麦克风的最佳组合进行语音聊天。</td>
</tr>
<tr>
<td>AVAudioSessionModeGameChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>适用于游戏App，该模式会由 <code>GameKie</code> 的 <code>GKVoiceChat</code> 对象自动设置，而不要手动设置，游戏聊天模式使用的参数与视频模式相同</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoRecording</td>
<td>AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryRecord</td>
<td>适用于视频录制的App。使用 <code>AVCaptureSession</code> 的API可以更好的控制输入和输出。例如设置 <code>automaticallyConfiguresApplicationAudioSession</code> 属性会自动选择最佳的设备和相机</td>
</tr>
<tr>
<td>AVAudioSessionModeMoviePlayback</td>
<td>AVAudioSessionCategoryPlayback</td>
<td>适用于播放电影的App</td>
</tr>
<tr>
<td>AVAudioSessionModeMeasurement</td>
<td>AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryRecord<br> AVAudioSessionCategoryPlayback</td>
<td>减少设备在处理音频 I/O 的信号量时的影响。输入信号通过设备的主麦克风转换</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>用于视频聊天App，该模式可以设置选项 <code>AVAudioSessionCategoryOptionAllowBluetooth</code> 和 <code>AVAudioSessionCategoryOptionDefaultToSpeaker</code>。音频路由合集会优化语音聊天体验。使用内置麦克风时，系统会自动选择内置麦克风的最佳组合进行视频聊天。</td>
</tr>
<tr>
<td>AVAudioSessionModeSpokenAudio (iOS 9)</td>
<td>AVAudioSessionCategoryPlayback</td>
<td>适用于连续播报语音（例如天气语音）时，在另一个App（如导航应用）播放语音提示时暂停音频（通过 AudioSessionInterruption 的方式）而不是混合或混淆（mixes or ducks）。该模式可以设置选项 <code>AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers</code>。</td>
</tr>
</tbody>
</table>
<p>苹果官方建议语音聊天或视频聊天的App也使用 <strong>Voice-Processing I/O</strong> 音频单元，<strong>Voice-Processing I/O</strong> 为 VoIP 提供了包括自动增益校正、语音处理调整等功能，详细参照 <a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/UsingSpecificAudioUnits/UsingSpecificAudioUnits.html#//apple_ref/doc/uid/TP40009492-CH17-SW6" target="_blank" rel="external">Audio Unit Hosting Guide for iOS</a></p>
<p>设备支持的模式可以通过 <code>availableModes</code> 属性（iOS 9之后才支持）获取，可以通过这个属性判断待设置的类别设备是否支持，例如不支持音频输入的设备中，<code>AVAudioSessionModeVideoRecording</code> 模式不会生效。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioSession = <span class="type">AVAudioSession</span>.sharedInstance()</div><div class="line"></div><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</div><div class="line">	<span class="keyword">if</span> audioSession.availableModes.<span class="built_in">contains</span>(<span class="type">AVAudioSessionModeVideoRecording</span>) &#123;</div><div class="line">		<span class="keyword">try</span>? audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayAndRecord</span>)</div><div class="line">		<span class="keyword">try</span>? audioSession.setMode(<span class="type">AVAudioSessionModeVideoRecording</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">try</span>? audioSession.setCategory(<span class="type">AVAudioSessionCategoryPlayback</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取当前模式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> currentAudioSessionMode = <span class="type">AVAudioSession</span>.sharedInstance().mode</div></pre></td></tr></table></figure>
<h4 id="七种选项"><a href="#七种选项" class="headerlink" title="七种选项"></a>七种选项</h4><p>通过设置 <code>AVAudioSessionCategoryOptions</code> 可以微调音频会话类别的默认行为。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>兼容的类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mixWithOthers</td>
<td>AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryPlayback<br> AVAudioSessionCategoryMultiRoute</td>
<td>在你的 App 激活 AudioSession 时，允许其他活动的音频 App 是否将被中断或混合</td>
</tr>
<tr>
<td>duckOthers</td>
<td>AVAudioSessionCategoryAmbient<br> AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryPlayback<br> AVAudioSessionCategoryMultiRoute</td>
<td>在你的 App 激活 AudioSession 时，其他活动的音频 App 将被忽略</td>
</tr>
<tr>
<td>allowBluetooth</td>
<td>AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryPlayAndRecord</td>
<td>允许 App 更改某些音频会话的默认行为，以蓝牙 HFP 设备显示为可用路由</td>
</tr>
<tr>
<td>defaultToSpeaker</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>允许App更改关于音频路由的 AudioSessionCategory 的一些默认行为</td>
</tr>
<tr>
<td>interruptSpokenAudioAndMixWithOthers (iOS 9)</td>
<td>AVAudioSessionCategoryPlayAndRecord<br> AVAudioSessionCategoryPlayback<br> AVAudioSessionCategoryMultiRoute</td>
<td>如果另一个 App 的音频会话模式设置为 <code>AVAudioSessionModeSpokenAudio</code> 时，则当前 App 激活 AudioSession 时其他 App 的音频将被中断。例如你的 App 是天气预报播报应用，在播放天气时将会停止其他App（如导航应用）的任何播报语音</td>
</tr>
<tr>
<td>allowBluetoothA2DP (iOS 10)</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>允许 App 更改某些音频会话的默认行为，以蓝牙 A2DP 设备显示为可用路由。<br> 可以同时设置 <code>AVAudioSessionCategoryOptionAllowBluetooth</code> 和 <code>AVAudioSessionCategoryOptionAllowBluetoothA2DP</code>，在单个蓝牙设备同时支持 HFP 和 A2DP 的情况下，HFP 端口的优先级更高</td>
</tr>
<tr>
<td>allowAirPlay (iOS 10)</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>允许 App 更改某些音频会话的默认行为，以将 AirPlay 设备显示为可用路由。</td>
</tr>
</tbody>
</table>
<p>获取当前模式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> currentAudioSessionCategoryOptions = <span class="type">AVAudioSession</span>.sharedInstance().categoryOptions</div></pre></td></tr></table></figure>
<blockquote>
<p>关于类别、模式以及选项的选择，可以参照苹果官方的指导方针附录 <a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioGuidelinesByAppType/AudioGuidelinesByAppType.html#//apple_ref/doc/uid/TP40007875-CH11-SW1" target="_blank" rel="external">Audio Guidelines By App Type</a>。</p>
</blockquote>
<h3 id="三、AVAudioPlayer"><a href="#三、AVAudioPlayer" class="headerlink" title="三、AVAudioPlayer"></a>三、AVAudioPlayer</h3><p>在设置好音频的播放行为模式后，就可以通过 <code>AVAudioPlayer</code> 类来控制音频播放。</p>
<h4 id="初始化播放器"><a href="#初始化播放器" class="headerlink" title="初始化播放器"></a>初始化播放器</h4><p>可以通过文件 URL 或者文件二进制数据的方式初始化播放器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">let</span> player = <span class="keyword">try</span> <span class="type">AVAudioPlayer</span>(contentsOf: audioURL)</div><div class="line">    <span class="comment">// let player = try AVAudioPlayer(data: audioData)</span></div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"AVAudioPlayer initial faild, <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外还有两个扩展初始化方法，需要指定具体的数据格式 UTI，例如 mp3 音频文件可传入 <code>AVFileTypeMPEGLayer3</code> ，其他数据格式可参照 <em>AVMediaFormat.h</em> 头文件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(contentsOf url: <span class="type">URL</span>, fileTypeHint utiString: <span class="type">String</span>?) <span class="keyword">throws</span></div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(data: <span class="type">Data</span>, fileTypeHint utiString: <span class="type">String</span>?) <span class="keyword">throws</span></div></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> audioIsPlaying = audioPlayer.isPlaying    <span class="comment">// 判断当前播放器是否播放</span></div><div class="line">progressSlider.maximumValue = player.duration <span class="comment">// 音频总时长</span></div><div class="line"></div><div class="line">audioPlayer.volume = <span class="number">0.5</span>   <span class="comment">// 声音大小</span></div><div class="line"></div><div class="line">audioPlayer.pan = <span class="number">0.0</span>            <span class="comment">// 设置左右声道，-1.0表示左声道，0.0表示中间，1.0表示右声道</span></div><div class="line">audioPlayer.numberOfChannels = <span class="number">2</span> <span class="comment">// 设置为双声道</span></div><div class="line"></div><div class="line">audioPlayer.enableRate = <span class="literal">true</span> <span class="comment">// 允许改变播放速率，必须在调用 prepareToPlay() 方法前设置</span></div><div class="line">audioPlayer.rate = <span class="number">1.0</span>        <span class="comment">// 1.0表示正常，0.5表示一半的速率，2.0表示两倍速率</span></div><div class="line"></div><div class="line"><span class="comment">// 循环播放次数，0表示只播放一次，1表示播放两次，依次类推，每播放一次-1</span></div><div class="line"><span class="comment">// 负数表示无限循环，除非手动调用 audioPlayer.stop()</span></div><div class="line">audioPlayer.numberOfLoops = <span class="number">3</span></div><div class="line"></div><div class="line"><span class="comment">// 当前播放时长，单位为秒</span></div><div class="line"><span class="comment">// 如果是调用 setter 方法，那么将改变音频的播放位置</span></div><div class="line">progressSlider.value = audioPlayer.currentTime</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">progressSliderValueChanged</span><span class="params">(<span class="number">_</span> sender: UISlider)</span></span> &#123;</div><div class="line">    audioPlayer.currentTime = <span class="type">TimeInterval</span>(sender.value)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设备当前时间，单位为秒，配合 play(atTime:) 方法使用</span></div><div class="line"><span class="keyword">let</span> deviceCurrentTime = audioPlayer.deviceCurrentTime</div><div class="line"></div><div class="line"><span class="comment">// 允许使用音频仪表，必须在调用 prepareToPlay() 方法前设置</span></div><div class="line">audioPlayer.isMeteringEnabled = <span class="literal">true</span></div></pre></td></tr></table></figure>
<h4 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 准备播放，如果该音频可以播放则返回 true</span></div><div class="line"><span class="comment">// 当 AVAudioSession 的类别为 AVAudioSessionCategoryRecord 或设备处于不可播放状态时，该方法返回 false</span></div><div class="line">audioPlayer.prepareToPlay()</div><div class="line"></div><div class="line"><span class="comment">// 播放音频，播放成功返回 true, 失败返回 false</span></div><div class="line"><span class="comment">// 当 AVAudioSession 的类别为 AVAudioSessionCategoryRecord 或设备处于不可播放状态时，该方法返回 false</span></div><div class="line">audioPlayer.play()</div><div class="line"></div><div class="line"><span class="keyword">let</span> currentTime = audioPlayer.deviceCurrentTime</div><div class="line">audioPlayer.play(atTime: currentTime + <span class="number">3</span>) <span class="comment">// 3秒后播放</span></div><div class="line"></div><div class="line"><span class="comment">// 暂停播放，可以通过 play() 恢复播放</span></div><div class="line">audioPlayer.pause()</div><div class="line"></div><div class="line"><span class="comment">// 停止播放，通过 play() 无法恢复播放，当 numberOfLoops 为负数时，可以调用该方法停止播放</span></div><div class="line">audioPlayer.stop()</div></pre></td></tr></table></figure>
<h4 id="监听播放进度"><a href="#监听播放进度" class="headerlink" title="监听播放进度"></a>监听播放进度</h4><p>可以通过定时器的方式来监听音频播放的进度，如果需要显示音频谱，也可以在这个时机刷新视图</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> timer = <span class="type">Timer</span>(timeInterval: <span class="number">0.1</span>, target: <span class="keyword">self</span>, selector: #selector(updatePlayProgress), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</div><div class="line"><span class="type">RunLoop</span>.current.add(timer, forMode: .commonModes)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">updatePlayProgress</span><span class="params">()</span></span> &#123;</div><div class="line">    progressSlider.value = <span class="type">Float</span>(audioPlayer.currentTime)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> audioPlayer.isMeteringEnabled &#123;</div><div class="line">        <span class="comment">// 必须先刷新仪表数据</span></div><div class="line">        audioPlayer.updateMeters()</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> peakPower = audioPlayer.peakPower(forChannel: <span class="number">0</span>)</div><div class="line">        <span class="keyword">let</span> averagePower = audioPlayer.averagePower(forChannel: <span class="number">0</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// ....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AVAudioPlayerDelegate"><a href="#AVAudioPlayerDelegate" class="headerlink" title="AVAudioPlayerDelegate"></a>AVAudioPlayerDelegate</h4><p>通过代理方法可以获取音频播放完毕或解码失败的回调方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 音频播放完毕，如果 player.numberOfLoops 不为0，音频播放完毕时不会调用该方法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">audioPlayerDidFinishPlaying</span><span class="params">(<span class="number">_</span> player: AVAudioPlayer, successfully flag: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">switch</span> currentLoopMode &#123;</div><div class="line">    <span class="keyword">case</span> .singleLoop:</div><div class="line">        <span class="comment">// 如果单曲循环回调该方法，那么说明 player 的 numberOfLoops 已经为0，可以重新设置该属性</span></div><div class="line">        player.numberOfLoops = <span class="type">NSIntegerMax</span></div><div class="line">        startPlay(index: currentTrackIndex)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        playNextAudio()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 解码失败</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">audioPlayerDecodeErrorDidOccur</span><span class="params">(<span class="number">_</span> player: AVAudioPlayer, error: Error?)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"audio player decode error: <span class="subst">\(error?.localizedDescription ?? "unknown")</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>特别需要注意的是，<code>AVAudioPlayer</code> 的 <code>delegate</code> 属性是不安全的无主引用，在 OC 中体现为 <code>assign</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// swift</span></div><div class="line"><span class="keyword">unowned</span>(unsafe) open <span class="keyword">var</span> delegate: <span class="type">AVAudioPlayerDelegate</span>?</div><div class="line"></div><div class="line"><span class="comment">// OC</span></div><div class="line">@property(assign, nullable) id&lt;<span class="type">AVAudioPlayerDelegate</span>&gt; delegate;</div></pre></td></tr></table></figure>
<p>因此当播放器的代理对象销毁时，尽量把 <code>delegate</code> 设置为 <code>nil</code>，以免造成野指针崩溃。</p>
<blockquote>
<p>AVAudioPlayer 不支持流式播放，如果想要实现边播边存的流式播放，可以使用 AVPlayer + AVURLAsset + 自定义AVAssetResourceLoader，将下载的数据通过 AVAssetResourceLoaderDelegate 和 AVPlayer 按需加载</p>
<p>还有一种方法是使用音频队列服务，通过 Audio File Stream Services（AudioToolbox/AudioFileStream.h） 将网络数据包解析成音频包，最后通过 Audio Queue Services（AudioToolbox/AudioQueue.h）进行播放。</p>
<p>see <a href="https://developer.apple.com/library/content/qa/qa1634/_index.html#//apple_ref/doc/uid/DTS40008185" target="_blank" rel="external">AVAudioPlayer Streaming Support</a></p>
</blockquote>
<h3 id="四、音频会话中断处理"><a href="#四、音频会话中断处理" class="headerlink" title="四、音频会话中断处理"></a>四、音频会话中断处理</h3><p>当来电、闹钟响起或其他 App 激活 <code>AVAudioSession</code> 时，就会发生<strong>音频中断开始</strong>事件。在接收到中断事件时，可以进行状态保存、暂停格式转换、更新用户界面等操作。当用户忽略或挂断电话、忽略或关闭闹钟时，系统会发出<strong>音频中断结束</strong>消息，App可以继续运行，此时可以恢复状态、更新用户界面。</p>
<h4 id="AVAudioSession-的中断通知"><a href="#AVAudioSession-的中断通知" class="headerlink" title="AVAudioSession 的中断通知"></a>AVAudioSession 的中断通知</h4><p>在 iOS 6 以前，<code>AVAudioSession</code> 中断可以通过代理方法获取，在 iOS 6 以后由通知处理。并在 iOS 8 开始</p>
<p>监听 <code>AVAudioSessionInterruptionNotification</code> 获得中断事件，在 <code>userInfo</code> 中会携带关于中断/中断结束，以及音频是否可以恢复播放参数 。</p>
<h5 id="中断事件类型"><a href="#中断事件类型" class="headerlink" title="中断事件类型"></a>中断事件类型</h5><p>通过 <code>AVAudioSessionInterruptionTypeKey</code> 获取 <code>AVAudioSessionInterruptionType</code> 枚举值：</p>
<ul>
<li><code>began</code> （value = 1）表示中断事件开始</li>
<li><code>ended</code> （value = 0）表示中断事件结束</li>
</ul>
<p>发生音频中断时，<code>AVAudioPlayer</code> 和 <code>AVAudioRecorder</code> 类，音频队列服务（Audio Queue Services），以及系统声音服务（System Sound Services）会自动暂停播放或录制。</p>
<p>当使用OpenAL进行音频播放时，实现中断监听器回调函数，就像使用音频队列服务一样。但是中断代码必须另外管理OpenAL上下文。中断后，将OpenAL上下文设置为<code>NULL</code>。中断结束后，将上下文设置为先前状态。</p>
<h5 id="中断事件选项"><a href="#中断事件选项" class="headerlink" title="中断事件选项"></a>中断事件选项</h5><p>通过 <code>AVAudioSessionInterruptionOptionKey</code> 获取 <code>AVAudioSessionInterruptionOptions</code> 选项：</p>
<ul>
<li><code>shouldResume</code> （value = 1）表示音频可以恢复播放或录音</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听通知</span></div><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(handleInterruption(<span class="number">_</span>:)), name: .<span class="type">AVAudioSessionInterruption</span>, object: <span class="type">AVAudioSession</span>.sharedInstance())</div><div class="line"></div><div class="line"><span class="comment">// 处理中断情况</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleInterruption</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span></div><div class="line">        <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">        <span class="keyword">let</span> typeNumber = userInfo[<span class="type">AVAudioSessionInterruptionTypeKey</span>] <span class="keyword">as</span>? <span class="type">NSNumber</span>,</div><div class="line">        <span class="keyword">let</span> type = <span class="type">AVAudioSessionInterruptionType</span>(rawValue: typeNumber.uintValue) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">                </div><div class="line">    <span class="keyword">switch</span> type &#123;</div><div class="line">    <span class="keyword">case</span> .began:</div><div class="line">        <span class="keyword">if</span> audioPlayer.isPlaying &#123;</div><div class="line">            shouldResumePlay = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        updateUIForAudioPause()</div><div class="line">            </div><div class="line">    <span class="keyword">case</span> .ended:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> optionsNumber = userInfo[<span class="type">AVAudioSessionInterruptionOptionKey</span>] <span class="keyword">as</span>? <span class="type">NSNumber</span> &#123;</div><div class="line">           <span class="keyword">let</span> options = <span class="type">AVAudioSessionInterruptionOptions</span>(rawValue: optionsNumber.uintValue)</div><div class="line">           <span class="keyword">if</span> options.<span class="built_in">contains</span>(.shouldResume), shouldResumePlay &#123;</div><div class="line">                <span class="comment">// 自动恢复播放</span></div><div class="line">                <span class="keyword">if</span> audioPlayer.play() &#123;</div><div class="line">                    <span class="comment">// 更新视图为播放状态</span></div><div class="line">                    updateUIForAudioPlayback()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">		&#125;</div><div class="line">		shouldResumePlay = <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS 10.3 之后还增加了判断应用是否被挂起，而不是被另一个音频会话中断的参数，通过 <code>AVAudioSessionInterruptionWasSuspendedKey</code> 获取，其值是一个 <code>bool</code> 类型的 <code>NSNumber</code> 对象。</p>
<p>按照官方的说，从iOS 10开始，系统将停用大多数应用程序的音频会话，以响应应用程序进程被暂停。 当应用程序再次开始运行时，系统将收到其会话已被停用的通知。 值得注意的是，由于系统停用会话时暂停应用程序，通知必须及时延迟，并且只有在应用程序再次运行时，才能发送通知。</p>
<h4 id="AVAudioPlayer-和-AVAudioRecorder-的中断代理方法"><a href="#AVAudioPlayer-和-AVAudioRecorder-的中断代理方法" class="headerlink" title="AVAudioPlayer 和 AVAudioRecorder 的中断代理方法"></a>AVAudioPlayer 和 AVAudioRecorder 的中断代理方法</h4><p><code>AVAudioPlayer</code> 和 <code>AVAudioRecorder</code> 提供各自的中断代理方法，但从 iOS 8 开始均被弃用，统一由 <code>AVAudioSessionInterruptionNotification</code> 处理。</p>
<h3 id="五、输入输出设备切换处理"><a href="#五、输入输出设备切换处理" class="headerlink" title="五、输入输出设备切换处理"></a>五、输入输出设备切换处理</h3><p>在 App 运行时，用户可能会插入或拔出耳机，使用蓝牙扬声器等，这时会涉及音频硬件路由变更。</p>
<p>以拔插耳机为例，在 <a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="external">iOS Human Interface Guidelines</a> 中苹果建议，用户在插入耳机时自动切换硬件路由，不会中断音频的播放；当拔出耳机时播放立即停止。</p>
<img src="/2017/04/04/AVFAudio-iOS音频播放/audio_route_change.png" alt="Handling audio hardware route changes" title="Handling audio hardware route changes">
<p>这时候可以通过监听 <code>AVAudioSessionRouteChangeNotification</code> 通知来获取硬件路由切换消息，通知消息中的 <code>userInfo</code> 会携带两个参数：1.硬件路由改变的原因；2.上一个路由是什么。</p>
<h5 id="硬件路由改变的原因"><a href="#硬件路由改变的原因" class="headerlink" title="硬件路由改变的原因"></a>硬件路由改变的原因</h5><p>通过 <code>AVAudioSessionRouteChangeReasonKey</code> 获取切换原因 <code>AVAudioSessionRouteChangeReason</code> 枚举值</p>
<table>
<thead>
<tr>
<th>切换原因</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unknown</td>
<td>原因不明</td>
</tr>
<tr>
<td>newDeviceAvailable</td>
<td>一个新设备可用（例如：耳机插入）</td>
</tr>
<tr>
<td>oldDeviceUnavailable</td>
<td>一个旧设备不可用（例如：耳机已拔出）</td>
</tr>
<tr>
<td>categoryChange</td>
<td>音频类别改变（例如：从 <code>AVAudioSessionCategoryPlayback</code> 变为 <code>AVAudioSessionCategoryPlayAndRecord</code></td>
</tr>
<tr>
<td>override</td>
<td>route 被重写（例如：<code>AVAudioSessionCategoryPlayAndRecord</code> 类别，输出从默认的接收器变为内置扬声器）</td>
</tr>
<tr>
<td>wakeFromSleep</td>
<td>设备从休眠中唤醒</td>
</tr>
<tr>
<td>noSuitableRouteForCategory</td>
<td>没有支持当前类别的输出/输入设备（例如：当前类别为 <code>AVAudioSessionCategoryRecord</code> 却没有可用的输入设备）</td>
</tr>
<tr>
<td>routeConfigurationChange</td>
<td>输入/输出端口没有改变但其配置的参数改变（例如：端口所选数据源已变更）</td>
</tr>
</tbody>
</table>
<h5 id="上一个路由是什么"><a href="#上一个路由是什么" class="headerlink" title="上一个路由是什么"></a>上一个路由是什么</h5><p>通过 <code>AVAudioSessionRouteChangePreviousRouteKey</code> 获取更换之前的音频路由信息的描述对象 <code>AVAudioSessionRouteDescription</code> 。</p>
<p>路由描述对象包括两个属性：<code>inputs</code> 数组和 <code>outputs</code> 数组属性，这两个数组的元素都是 <code>AVAudioSessionPortDescription</code> 类，用于描述路由端口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">AVAudioSessionRouteDescription</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    open <span class="keyword">var</span> inputs: [<span class="type">AVAudioSessionPortDescription</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> outputs: [<span class="type">AVAudioSessionPortDescription</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>路由端口描述对象包含了端口类型（）、名称、uid等属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">AVAudioSessionPortDescription</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    open <span class="keyword">var</span> portType: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> portName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    open <span class="keyword">var</span> uid: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如插入耳机时获取上一个路由描述，其中输入设备是内置麦克风，输入设备是内置扬声器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="type">AVAudioSessionRouteDescription</span>: <span class="number">0x17001e4b0</span>, </div><div class="line">  inputs = (</div><div class="line">    <span class="string">"&lt;AVAudioSessionPortDescription: 0x17001e300, type = MicrophoneBuiltIn; name = iPhone 麦克风; UID = Built-In Microphone; selectedDataSource = 前&gt;"</span></div><div class="line">  ); </div><div class="line">  outputs = (</div><div class="line">    <span class="string">"&lt;AVAudioSessionPortDescription: 0x17001ebf0, type = Speaker; name = 扬声器; UID = Speaker; selectedDataSource = (null)&gt;"</span></div><div class="line">  )</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>拔出耳机时的上一个路由描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="type">AVAudioSessionRouteDescription</span>: <span class="number">0x17401e1b0</span>, </div><div class="line">  inputs = (</div><div class="line">    <span class="string">"&lt;AVAudioSessionPortDescription: 0x17401e220, type = MicrophoneBuiltIn; name = iPhone 麦克风; UID = Built-In Microphone; selectedDataSource = 前&gt;"</span></div><div class="line">  ); </div><div class="line">  outputs = (</div><div class="line">    <span class="string">"&lt;AVAudioSessionPortDescription: 0x174202980, type = Headphones; name = 耳机; UID = Wired Headphones; selectedDataSource = (null)&gt;"</span></div><div class="line">  )</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>在播出耳机时暂停音频播放:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(handleRouteChange(<span class="number">_</span>:)), name: .<span class="type">AVAudioSessionRouteChange</span>, object: <span class="type">AVAudioSession</span>.sharedInstance())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRouteChange</span><span class="params">(<span class="number">_</span> notification: Notification)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span></div><div class="line">        <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">        <span class="keyword">let</span> routeChangeReasonNumber = userInfo[<span class="type">AVAudioSessionRouteChangeReasonKey</span>] <span class="keyword">as</span>? <span class="type">NSNumber</span>,</div><div class="line">        <span class="keyword">let</span> routeChangeReason = <span class="type">AVAudioSessionRouteChangeReason</span>(rawValue: routeChangeReasonNumber.uintValue) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> previousRoute = userInfo[<span class="type">AVAudioSessionRouteChangePreviousRouteKey</span>] <span class="keyword">as</span>? <span class="type">AVAudioSessionRouteDescription</span>, previousRoute.outputs.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">                </div><div class="line">    <span class="keyword">switch</span> routeChangeReason &#123;</div><div class="line">    <span class="keyword">case</span> .oldDeviceUnavailable:</div><div class="line">        <span class="keyword">let</span> portDescription = previousRoute.outputs.first!</div><div class="line">        <span class="keyword">if</span> portDescription.portType == <span class="string">"Headphones"</span> &#123;</div><div class="line">            audioPlayer.pause()</div><div class="line">            updateUIForAudioPause()</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// other ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="六、辅助音频静音处理"><a href="#六、辅助音频静音处理" class="headerlink" title="六、辅助音频静音处理"></a>六、辅助音频静音处理</h3><p>监听 <code>AVAudioSessionInterruptionNotification</code> 获得可选辅助音频静音的提示事件，在 <code>userInfo</code> 中会携带关于提示参数 ，通过 <code>AVAudioSessionSilenceSecondaryAudioHintTypeKey</code> 获取，其值是 <code>AVAudioSessionSilenceSecondaryAudioHintType</code> 类型：</p>
<ul>
<li><code>begin</code> 表示另一个 App 主音频已打开，自己的辅助音频开始静音</li>
<li><code>end</code> 表示另一个 App 主音频已停止，自己的辅助音频可以恢复</li>
</ul>
<p>可配合 <code>AVAudioSession</code> 的 <code>secondaryAudioShouldBeSilencedHint</code><br>属性（iOS 8 以后支持）一起使用，当其他的App正在播放非混音（non-mixable）音频时该属性返回 <code>true</code>。例如使用 <code>AVAudioSessionCategoryAmbient</code> 的游戏 App 可能会使用该属性来决定将其音轨静音，同时保持游戏的声效不静音。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</div><div class="line">open <span class="keyword">var</span> isOtherAudioPlaying: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<p>另外有个属性 <code>isOtherAudioPlaying</code> 用于判断其他 App 是否播放音频。但苹果建议在 iOS 8 以后使用 <code>secondaryAudioShouldBeSilencedHint</code> 属性来判断。</p>
<p>因为其他App播放任何音频 <code>isOtherAudioPlaying</code> 就会返回 <code>true</code>，而 <code>secondaryAudioShouldBeSilencedHint</code> 判断其他 App 是否播放的是主音频而不是辅助音频，因此更具有限制性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</div><div class="line">open <span class="keyword">var</span> secondaryAudioShouldBeSilencedHint: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875" target="_blank" rel="external">[1] Audio Session Programming Guide</a></p>
<p><a href="https://developer.apple.com/reference/avfoundation/avaudiosession" target="_blank" rel="external">[2] AVAudioSession Class Reference</a></p>
<p><a href="https://developer.apple.com/reference/avfoundation/avaudioplayer" target="_blank" rel="external">[3] AVAudioPlayer Class Reference</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/04/02/初识AVKit和AVFoundation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/02/初识AVKit和AVFoundation/" itemprop="url">
                  初识 AVKit & AVFoundation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-02T16:05:05+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Media/" itemprop="url" rel="index">
                    <span itemprop="name">Media</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>AVFoundation</code> 是一套关于多媒体数据的框架，可以用它来创建、编辑或者重新编码媒体文件，包括音频、视频、图像识别等。</p>
<p><code>AVKit</code> 是建立在 <code>AVFoudation</code> 和 <code>UIKit</code> 之上的框架，该框架提供一个简易的播放器界面，让开发者更简单的实现播放音频和视频功能。</p>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><img src="/2017/04/02/初识AVKit和AVFoundation/frameworks_block_diagram_iOS.png" alt="AVFoundation stack on iOS" title="AVFoundation stack on iOS">
<img src="/2017/04/02/初识AVKit和AVFoundation/frameworks_block_diagram_OSX.png" alt="AVFoundation stack on OSX" title="AVFoundation stack on OSX">
<p>最顶层的 <code>AVKit</code> 包含了用于播放音视频的视图控制器 <code>AVPlayerViewController</code> ，该控制器在 iOS 8 后可以使用，用于取代 <code>MPMoviePlayerViewController</code> 。在 iOS 9 中加入 <code>AVPictureInPictureController</code> 用于以“画中画”的形式播放视频。</p>
<p><code>AVKit</code> 的主要功能由 <code>AVFoundation</code> 实现，<code>AVFoundation</code> 包含多媒体数据获取、视频播放、编辑等功能，其中还包括一个用于处理音频的子框架 <code>AVFAudio</code> 。</p>
<p><code>AVFoundation</code> 的核心功能由 <code>CoreMedia</code>、<code>CoreAudio</code>、<code>CoreVideo</code>、<code>CoreAnimation</code> 等底层框架提供实现，这些框架提供了 C 级别接口以及媒体数据的结构和描述。</p>
<p>苹果推荐尽量使用高级别的框架。例如，仅仅需要播放视频功能，但不需要在交互上有太多设计，那么可以直接使用 <code>AVKit</code> 中的 <code>AVPlayerViewController</code> 即可。或者需要拍照或录制视频功能，但不需要裁剪和编辑时可以直接使用 <code>UIKit</code> 中的 <code>UIImagePickerController</code> 。当需要定制一些内容时才考虑使用底层的框架实现。</p>
<h2 id="AVFoundation"><a href="#AVFoundation" class="headerlink" title="AVFoundation"></a>AVFoundation</h2><p><code>AVFoundation</code> 的功能很强大，其最常用的功能之一就是媒体播放。</p>
<p>这套框架支持播放主流格式的视频、音频，还可以通过 HTTP Live Streaming 远程播放。在播放时可以显示字幕、切换音频等，甚至还可以在播放过程中对媒体数据进行实时处理。</p>
<h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p><code>AVFoundation</code> 中最常用的一个类就是 <code>AVPlayer</code> ，通过这个播放器类可以播放远程或者本地的音视频文件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> player = <span class="type">AVPlayer</span>(url: url)</div></pre></td></tr></table></figure>
<p>如果仅仅是播放音频，此时只需要调用 <code>play</code> 方法就可以了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始播放</span></div><div class="line">player.play()</div></pre></td></tr></table></figure>
<h3 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h3><p>除了通过 URL 初始化 <code>AVPlayer</code> 外还可以通过 <code>AVPlayerItem</code> 实例对象初始化，<code>AVPlayerItem</code> 提供了播放单元数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playerItem = <span class="type">AVPlayerItem</span>(url: url)</div><div class="line"><span class="keyword">let</span> player = <span class="type">AVPlayer</span>(playerItem: playerItem)</div></pre></td></tr></table></figure>
<p>除了直接通过 URL 加载 AVPlayerItem 外，还可以使用 AVAsset 或子类 AVURLAsset 初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> asset = <span class="type">AVURLAsset</span>(url: url, options: <span class="literal">nil</span>)</div><div class="line"><span class="keyword">let</span> playerItem2 = <span class="type">AVPlayerItem</span>(asset: asset)</div><div class="line"></div><div class="line"><span class="comment">// 在 item 状态变为 AVPlayerItemStatusReadyToPlay 之前，数组中的每个key对应的值自动被底层的AVAsset自动加载</span></div><div class="line"><span class="keyword">let</span> assetKeysRequiredToPlay = [<span class="string">"playable"</span>, <span class="string">"hasProtectedContent"</span>]</div><div class="line"><span class="keyword">let</span> playerItem3 = <span class="type">AVPlayerItem</span>(asset: asset, automaticallyLoadedAssetKeys:assetKeysRequiredToPlay)</div></pre></td></tr></table></figure>
<h3 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h3><p><code>AVPlayer</code> 并不涉及用户界面，如果需要显示视频，那么需要把 <code>AVPlayer</code> 放到 <code>AVPlayerLayer</code> 中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> playerLayer = <span class="type">AVPlayerLayer</span>(player: player)</div><div class="line">playerLayer.frame = <span class="keyword">self</span>.view.bounds</div><div class="line"><span class="keyword">self</span>.view.layer.addSublayer(playerLayer)</div><div class="line"></div><div class="line"><span class="comment">// 开始播放</span></div><div class="line">player.play()</div></pre></td></tr></table></figure>
<h3 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h3><p>如果以 MVC 来划分，<code>AVPlayerItem</code> 属于 <strong>Model</strong> 层，它提供了播放的数据来源；<code>AVPlayerLayer</code> 属于 <strong>View</strong> 层，负责向用户展现视频画面；<code>AVPlayer</code> 属于 <strong>Controller</strong> 层，负责控制音视频播放，Item 与 Layer 之间的数据交换等。</p>
<h3 id="通过-AVAssetImageGenerator-生成视频缩略图"><a href="#通过-AVAssetImageGenerator-生成视频缩略图" class="headerlink" title="通过 AVAssetImageGenerator 生成视频缩略图"></a>通过 AVAssetImageGenerator 生成视频缩略图</h3><p>结合 <code>AVURLAsset</code> 和 <code>AVAssetImageGenerator</code> 还可以生成视频指定时间的视频缩略图</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">thumbnailImage</span><span class="params">(from url: URL, time: CMTime)</span></span> -&gt; <span class="type">UIImage</span>? &#123;</div><div class="line">    <span class="keyword">let</span> asset = <span class="type">AVURLAsset</span>(url: url)</div><div class="line">    <span class="keyword">let</span> generator = <span class="type">AVAssetImageGenerator</span>(asset: asset)</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">let</span> thumbnailImageRef = <span class="keyword">try</span> generator.copyCGImage(at: time, actualTime: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: thumbnailImageRef)</div><div class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"error: <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/test.mp4"</span>)!</div><div class="line"><span class="keyword">let</span> thumbnailImage = thumbnailImage(from: url, time: <span class="type">CMTimeMake</span>(<span class="number">1</span>, <span class="number">60</span>))</div></pre></td></tr></table></figure>
<h2 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h2><p><code>AVKit</code> 是建立在 <code>AVFoudation</code> 和 <code>UIKit</code> 之上的框架，该框架提供一个简易的播放器界面，会根据播放的内容进行自动适配。并且还可以显示和隐藏字幕，显示导航章节标记等。</p>
<p>在 iOS 8 以前，播放视频的最简便方法就是通过 <code>MediaPlayer</code> 框架的 <code>MPMoviePlayerViewController</code> 类实现，该类是基于 <code>AVFoundation</code> 实现，但阻隔了 <code>AVFoundation</code> 的高级功能使用。在 iOS 8 以后 <code>AVKit</code> 提供了<code>AVPlayerViewController</code> 来替代它，并且在 iOS 9 时废弃了 <code>MPMoviePlayerViewController</code> 。</p>
<h3 id="AVPlayerViewController"><a href="#AVPlayerViewController" class="headerlink" title="AVPlayerViewController"></a>AVPlayerViewController</h3><p>使用 <code>AVPLayer</code> 需要做许多的额外工作，如果对播放交互没有太多要求，那么可以使用 <code>AVKit</code> 提供的<code>AVPlayerViewController</code> ，只要设置一个 <code>AVPlayer</code> 对象就可以播放本地或远程的视频或者音频文件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> fileURL = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"samplemovie"</span>, withExtension: <span class="string">"mov"</span>) <span class="keyword">else</span> &#123;</div><div class="line">	<span class="built_in">print</span>(<span class="string">"samplemovie.mov not found"</span>)</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">        </div><div class="line"><span class="keyword">let</span> playerViewController = <span class="type">AVPlayerViewController</span>()</div><div class="line">playerViewController.player = <span class="type">AVPlayer</span>(url: fileURL)</div><div class="line"></div><div class="line"><span class="comment">// 这里不使用 push 跳转，否则导航栏会遮挡 AVPlayerViewController 上方的控制栏</span></div><div class="line"><span class="keyword">self</span>.present(playerViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<img src="/2017/04/02/初识AVKit和AVFoundation/play_video.png" alt="Use AVPlayerViewController to play video" title="Use AVPlayerViewController to play video">
<img src="/2017/04/02/初识AVKit和AVFoundation/play_audio.png" alt="Use AVPlayerViewController to play audio" title="Use AVPlayerViewController to play audio">
<p>其他属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 是否显示顶部和底部的控制栏，默认为 true</span></div><div class="line">open <span class="keyword">var</span> showsPlaybackControls: <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// 视频显示样式，包含三种：AVLayerVideoGravityResizeAspect, AVLayerVideoGravityResizeAspectFill, AVLayerVideoGravityResize</span></div><div class="line"><span class="comment">// 默认为 AVLayerVideoGravityResizeAspect</span></div><div class="line">open <span class="keyword">var</span> videoGravity: <span class="type">String</span></div><div class="line"></div><div class="line"><span class="comment">// 当返回 true 时表示视频第一帧已经加载就绪</span></div><div class="line">open <span class="keyword">var</span> isReadyForDisplay: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 视频显示位置和大小，通常在第一帧加载完毕后才确定</span></div><div class="line">open <span class="keyword">var</span> videoBounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果需要添加自定义的控件，那么可以在这个视图上添加</span></div><div class="line"><span class="comment">// 这个视图位与视频内容之上和控制栏之下，在视频内容出现时才初始化</span></div><div class="line">open <span class="keyword">var</span> contentOverlayView: <span class="type">UIView</span>? &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 是否允许“画中画”模式播放，默认为 true, iOS 9 新增属性</span></div><div class="line">open <span class="keyword">var</span> allowsPictureInPicturePlayback: <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// 是否将当前播放信息更新到控制中心，如果设置为 true，那么控制中心将会显示当前播放的内容</span></div><div class="line"><span class="comment">// 通过控制中心可以控制内容的播放/暂停、快进/快退等，</span></div><div class="line"><span class="comment">// 默认为 true, iOS 10 新增属性</span></div><div class="line">open <span class="keyword">var</span> updatesNowPlayingInfoCenter: <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// 目前代理方法仅与“画中画”模式播放相关，iOS 9 新增属性</span></div><div class="line"><span class="keyword">weak</span> open <span class="keyword">var</span> delegate: <span class="type">AVPlayerViewControllerDelegate</span>?</div></pre></td></tr></table></figure>
<h3 id="AVPictureInPictureController"><a href="#AVPictureInPictureController" class="headerlink" title="AVPictureInPictureController"></a>AVPictureInPictureController</h3><p>使用 <code>AVPictureInPictureController</code> 以浮动窗口的形式播放视频，不过目前仅支持iPad，iPhone上无法初始化这个类。</p>
<h4 id="查看是否支持-AVPictureInPictureController"><a href="#查看是否支持-AVPictureInPictureController" class="headerlink" title="查看是否支持 AVPictureInPictureController"></a>查看是否支持 AVPictureInPictureController</h4><p>使用该类有三个前提条件：</p>
<ol>
<li>当前设备是 <strong>iPad</strong>；</li>
<li>开启 <strong>Background Modes</strong> 并勾选 <strong>Audio, AirPlay, and Picture in Pictur</strong></li>
<li>将 <code>AVAudioSession</code> 的类别设置为 <code>AVAudioSessionCategoryPlayback</code> 或者 <code>AVAudioSessionCategoryPlayAndRecord</code> </li>
</ol>
<p>可以通过类方法 <code>isPictureInPictureSupported</code> 检查是否支持 <code>AVPictureInPictureController</code> ，上面三个前提条件只要有一个不满足就返回 <code>false</code> 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pictureInPicturePossible = <span class="type">AVPictureInPictureController</span>.pictureInPicturePossible</div></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化 <code>AVPictureInPictureController</code> 仅需要一个 <code>AVPlayerLayer</code> 即可:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupPictureInPicturePlayback</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="type">AVPictureInPictureController</span>.isPictureInPictureSupported() &#123;</div><div class="line">		pictureInPictureController = <span class="type">AVPictureInPictureController</span>(playerLayer: playerView.playerLayer)</div><div class="line">		pictureInPictureController.delegate = <span class="keyword">self</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		pictureInPictureButton.isEnabled = <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，在初始化后如果改变 <code>AVAudioSession</code> 的类别为 <code>AVAudioSessionCategoryPlayback</code> 或 <code>AVAudioSessionCategoryPlayAndRecord</code> 以外的选项，那么会导致“画中画”模式不可用，可以通过实例对象的 <code>isPictureInPicturePossible</code> 属性判断是否可用</p>
<p>由于 <code>AVAudioSession</code> 可能在未知情况下改变，因此就需要在 <code>isPictureInPicturePossible</code> 属性改变时实时通知外部，因此可以在初始化的方法中利用KVO观察：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupPictureInPicturePlayback</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="type">AVPictureInPictureController</span>.isPictureInPictureSupported() &#123;</div><div class="line">		pictureInPictureController = <span class="type">AVPictureInPictureController</span>(playerLayer: playerView.playerLayer)</div><div class="line">		pictureInPictureController.delegate = <span class="keyword">self</span></div><div class="line">			</div><div class="line">		addObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(<span class="type">PlayerViewController</span>.pictureInPictureController.pictureInPicturePossible), options: [.new, .initial], context: &amp;playerViewControllerKVOContext)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		pictureInPictureButton.isEnabled = <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> playerViewControllerKVOContext = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</div><div class="line">	<span class="keyword">guard</span> context == &amp;playerViewControllerKVOContext <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</div><div class="line">         <span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	<span class="keyword">if</span> keyPath == #keyPath(<span class="type">PlayerViewController</span>.pictureInPictureController.pictureInPicturePossible) &#123;</div><div class="line">		<span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeKey</span>.newKey] <span class="keyword">as</span>! <span class="type">NSNumber</span></div><div class="line">		<span class="keyword">let</span> isPictureInPicturePossible: <span class="type">Bool</span> = newValue.boolValue</div><div class="line"></div><div class="line">		pictureInPictureButton.isEnabled = isPictureInPicturePossible</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="“画中画”按钮图标"><a href="#“画中画”按钮图标" class="headerlink" title="“画中画”按钮图标"></a>“画中画”按钮图标</h4><p>如果支持 <code>AVPictureInPictureController</code> 那么可以通过以下两个方法获取系统提供的“画中画”按钮图标</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始播放图片</span></div><div class="line"><span class="keyword">let</span> pipStartImage = <span class="type">AVPictureInPictureController</span>.pictureInPictureButtonStartImage(compatibleWith: <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// 结束播放图片，一般不需要获取这张图片，因为进入“画中画”模式后，播放界面有结束播放的按钮</span></div><div class="line"><span class="keyword">let</span> pipStopImage = <span class="type">AVPictureInPictureController</span>.pictureInPictureButtonStopImage(compatibleWith: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<h4 id="播放状态与播放控制"><a href="#播放状态与播放控制" class="headerlink" title="播放状态与播放控制"></a>播放状态与播放控制</h4><p>通过 <code>isPictureInPictureActive</code> , <code>isPictureInPictureSuspended</code> 属性获取是否正在活动/暂停状态，通过 <code>startPictureInPicture</code> 和 <code>stopPictureInPicture</code> 方法启动/停止“画中画”模式播放</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> pictureInPictureController.isPictureInPictureActive &#123;</div><div class="line">	<span class="comment">// 启动</span></div><div class="line">	pictureInPictureController.stopPictureInPicture()</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// 停止</span></div><div class="line">	pictureInPictureController.startPictureInPicture()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<img src="/2017/04/02/初识AVKit和AVFoundation/picture_in_picture.png" alt="picture_in_picture" title="picture_in_picture">
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40010188" target="_blank" rel="external">[1] AVFoundation Programming Guide</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/MediaPlaybackGuide/Contents/Resources/en.lproj/Introduction/Introduction.html#//apple_ref/doc/uid/TP40016757" target="_blank" rel="external">[2] Media Playback Programming Guide</a></p>
<p><a href="https://developer.apple.com/reference/avfoundation?language=objc" target="_blank" rel="external">[2] AVFoundation API Reference</a></p>
<p><a href="https://developer.apple.com/reference/avkit" target="_blank" rel="external">[3] AVKit API Reference</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/03/05/Associated-Object-Method-Swizzling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/Associated-Object-Method-Swizzling/" itemprop="url">
                  Associated Object & Method Swizzling
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T17:59:56+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 runtime 的实际应用中，<strong>关联对象</strong>再常见不过了，它提供一种“键—对象”形式的存取机制，在不改变源码的情况下，达到在运行时为类添加“成员变量”的目的。通过关联对象还可以解决在分类中不能为类添加新成员变量的问题。</p>
<p>除了关联对象，runtime 运用较多的就是<strong>方法调配</strong>，通过<strong>方法调配</strong>可以互相交换两个方法的实现（IMP）。</p>
<h2 id="关联对象（Associated-Object）"><a href="#关联对象（Associated-Object）" class="headerlink" title="关联对象（Associated Object）"></a>关联对象（Associated Object）</h2><p><strong>关联对象</strong>可以为指定的实例对象关联多个其他对象，这些对象将通过不同的“键”（ <code>void</code> 类型的指针）来区分。<strong>关联对象</strong>涉及三个函数，这些函数都可以在 <code>objc/runtime.h</code> 中找到定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 存储关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</div><div class="line"></div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</div></pre></td></tr></table></figure>
<p>在存储关联对象时，可以通过指定的存储策略枚举值来维护类似 @property 属性相应的内存管理语义：</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的 @property 属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic, retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic, copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody>
</table>
<p>设置关联对象时，如果希望完全相同的指针才能匹配得到同一个值，那么通常的做法是使用静态全局变量作为“键”。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *kExtraValKey = &amp;kExtraValKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span> (<span class="title">Extra</span>)</span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)setExtraVal:(<span class="keyword">id</span>)val </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 通过 kExtraValKey 关联额外变量</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kExtraValKey, val,  OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)extraVal </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 通过 kExtraValKey 获取额外变量</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kExtraValKey);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在<a href="https://arkenlee.github.io/2017/02/25/Messaging/">消息发送</a>中提到，<code>SEL</code> 是结构体 <code>objc_selector</code> 指针的别名： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>每个 <code>SEL</code> 在 runtime 中都是唯一的，因此也可以使用 <code>SEL</code> 作为“键”，从而节省了额外声明静态全局变量，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span> (<span class="title">Extra</span>)</span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)setExtraVal:(<span class="keyword">id</span>)val </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 通过 @selector(extraVal) 关联额外变量</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(extraVal), val,  OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)extraVal </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 每个方法中都有一个隐藏参数 _cmd 引用当前方法的 selector</span></div><div class="line">    <span class="comment">// 因此也可以通过 _cmd 即 @selector(extraVal) 获取额外变量</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)extraTags </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *tags = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (tags == <span class="literal">nil</span>) &#123;</div><div class="line">        tags = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, _cmd, tags, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tags;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>当一个对象被释放时，系统内部会自动调用 <code>objc_removeAssociatedObjects</code> 函数移除所有的关联对象。当然如果希望在恰当的时机提前移除，也可以自行调用该函数。</p>
<blockquote>
<p>在<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a>中有详细说明 runtime 是如何管理关联对象。</p>
</blockquote>
<h2 id="方法调配（Method-Swizzling）"><a href="#方法调配（Method-Swizzling）" class="headerlink" title="方法调配（Method Swizzling）"></a>方法调配（Method Swizzling）</h2><p>在<a href="https://arkenlee.github.io/2017/02/25/Messaging/">消息发送</a>中提到，在方法调度表中通过 <code>selector</code> 查找到对应的方法实现（即函数指针 <code>IMP</code> ），然后调用 <code>IMP</code> 来实现方法调用。</p>
<p>因此我们可以理解为每个 <code>selector</code> 都映射到了指定的 <code>IMP</code> ，而通过 runtime 的一些方法交换两个已有的方法实现则称作<strong>方法调配</strong>（没找到比较统一的译名，这里暂时用 【Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法】的译名）。</p>
<p>有时候希望在既有类的方法中统一添加某些操作，例如打印一些日志信息，但又不想在每次调用方法的代码后面加上日志信息操作代码，也不想通过继承的方式去重写原有的方法。那么可以先添加一个带有日志信息的方法，然后通过方法调配与原有的方法进行交换，可以优雅而简洁的解决这个问题。</p>
<p>例如在 <code>NSString</code> 中有一个将字符串转为小写的方法 <code>lowercaseString</code> ，我希望字符串在转为小写的同时能输出原有的字符串的比较信息，那么可以为 <code>NSString</code> 添加一个分类，自定义一个能输出比较信息的转小写方法，然后在 <code>load</code> 方法中交换它们：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"NSString+Add.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Add</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        Method orgMethodImp = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(lowercaseString));</div><div class="line">        Method dstMethodImp = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(myLowercaseString));</div><div class="line">        method_exchangeImplementations(orgMethodImp, dstMethodImp);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)myLowercaseString &#123;</div><div class="line">    <span class="built_in">NSString</span> *lowercaseStr = [<span class="keyword">self</span> myLowercaseString];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ -&gt; %@"</span>, <span class="keyword">self</span>, lowercaseStr);  <span class="comment">// 输出比较信息</span></div><div class="line">    <span class="keyword">return</span> lowercaseStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里在 <code>myLowercaseString</code> 中调用了 <code>myLowercaseString</code> 方法并不会造成死循环，这是因为在运行期 <code>myLowercaseString</code> 的 <code>IMP</code> 实际上对应的是原来的 <code>lowercaseString</code> 的 <code>IMP</code> ，因此这里调用的方法实际上还是原来的转小写方法，并不会造成死循环。</p>
<h3 id="为什么在-load-方法中交换，并且在-dispatch-once-中执行？"><a href="#为什么在-load-方法中交换，并且在-dispatch-once-中执行？" class="headerlink" title="为什么在 load 方法中交换，并且在 dispatch_once 中执行？"></a>为什么在 <code>load</code> 方法中交换，并且在 <code>dispatch_once</code> 中执行？</h3><p>在程序加载时，系统将每个类加载到内存中分配空间，此时优先将类定义中的方法添加到方法调度表（methodList）中，而类别中的方法是后添加（<em>各类别的添加顺序与.m文件连接顺序有关，可在项目工程的 Targets -&gt; Build Phases 的 Compile Sources 中查看文件顺序</em>），由于方法的添加采用的是头插法，因此类别的方法在”消息发送“的搜索过程中优先找到，造成类别方法会重写掉类定义的同名方法的现象。而 <code>load</code> 方法是在类加载到内存时，由 runtime 负责向类（按继承顺序递归）及类别调用，可以保证每个 <code>load</code> 方法都被调用一次。</p>
<p>由于使用方法调配会影响该类的全局状态，因此要尽量避免出现冲突或者遗漏的情况。在 <code>load</code> 方法中进行方法调配可以确保方法交换不会遗漏，在 <code>load</code> 方法中使用 GCD 的 <code>dispatch_once</code> 确保该段方法调配仅执行一次，保证方法交换的一致性。</p>
<h3 id="分类的加载顺序"><a href="#分类的加载顺序" class="headerlink" title="分类的加载顺序"></a>分类的加载顺序</h3><p>如果有两个分类 <code>NSString+Add1</code> 和 <code>NSString+Add2</code> 都交换了 <code>lowercaseString</code> 这两个分类的加载顺序是如何？</p>
<h4 id="1-文件的加载顺序"><a href="#1-文件的加载顺序" class="headerlink" title="1.文件的加载顺序"></a>1.文件的加载顺序</h4><p>在工程的 <strong>Build Phases</strong> —&gt; <strong>Compile Sources</strong> 可以看到文件的顺序，这里的文件决定了程序加载文件的顺序。以下图为例，程序在加载时会先加载<code>NSString+Add1</code> 然后再加载 <code>NSString+Add2</code>：</p>
<img src="/2017/03/05/Associated-Object-Method-Swizzling/compile_souces.png" alt="Compile Sources" title="Compile Sources">
<h4 id="2-交换同一个方法"><a href="#2-交换同一个方法" class="headerlink" title="2.交换同一个方法"></a>2.交换同一个方法</h4><p>假设这两个分类都交换了同一个方法<code>lowercaseString</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// NSString+Add1</div><div class="line">@implementation NSString (Add1)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Method orgMethodImp = class_getInstanceMethod(self, @selector(lowercaseString));</div><div class="line">        Method dstMethodImp = class_getInstanceMethod(self, @selector(myLowercaseString1));</div><div class="line">        method_exchangeImplementations(orgMethodImp, dstMethodImp);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)myLowercaseString1 &#123;</div><div class="line">    NSLog(@&quot;NSString+Add1 %@&quot;, NSStringFromSelector(_cmd));</div><div class="line">    NSString *lowercaseStr = [self myLowercaseString1];</div><div class="line">    return lowercaseStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// NSString+Add2</div><div class="line">@implementation NSString (Add2)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Method orgMethodImp = class_getInstanceMethod(self, @selector(lowercaseString));</div><div class="line">        Method dstMethodImp = class_getInstanceMethod(self, @selector(myLowercaseString2));</div><div class="line">        method_exchangeImplementations(orgMethodImp, dstMethodImp);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)myLowercaseString2 &#123;</div><div class="line">    NSLog(@&quot;NSString+Add2 %@&quot;, NSStringFromSelector(_cmd));</div><div class="line">    NSString *lowercaseStr = [self myLowercaseString2];</div><div class="line">    return lowercaseStr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>程序先加载<code>NSString+Add1</code> 于是<code>SEL</code> 和 <code>IMP</code> 的对应关系如下：</p>
<img src="/2017/03/05/Associated-Object-Method-Swizzling/swizzling1.png" alt="NSString+Add1" title="NSString+Add1">
<p>然后程序加载<code>NSString+Add2</code> ，最终 <code>SEL</code> 和 <code>IMP</code> 的对应关系如下：</p>
<img src="/2017/03/05/Associated-Object-Method-Swizzling/swizzling2.png" alt="NSString+Add2" title="NSString+Add2">
<p>此时我们在外部执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *str = @&quot;Hello, World&quot;;</div><div class="line">NSLog(@&quot;%@ -&gt; %@&quot;, str, str.lowercaseString);</div></pre></td></tr></table></figure>
<p>当调用 <code>-lowercaseString</code> 方法时执行顺序如下：</p>
<ol>
<li>找到 <code>myLowercaseString2</code> 的函数指针并执行</li>
<li>在 <code>myLowercaseString2</code> 方法中会调用 <code>[self myLowercaseString2]</code> ，找到 <code>myLowercaseString1</code> 的函数指针执行</li>
<li>在 <code>myLowercaseString1</code> 方法中会调用 <code>[self myLowercaseString1]</code> ，找到原始的 <code>lowercaseString</code> 的函数指针执行</li>
<li>返回小写字符串</li>
</ol>
<p>最终输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; NSString+Add2 lowercaseString</div><div class="line">&gt;&gt; NSString+Add1 myLowercaseString2</div><div class="line">&gt;&gt; Hello, World -&gt; hello, world</div></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>方法调配固然强大，但是这种”黑魔法“有一些潜在危险，如果使用得当可以让代码有质的飞跃，如果使用不当则会产生无法预知的后果。方法调配牵一发而动全身，尤其多次交换同一个方法，如果滥用该特性会令代码变得不易理解且难以维护，还会有”方法命名重复“的问题，因此在使用方法调配时要十分谨慎。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/02/26/Message-Forwarding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/26/Message-Forwarding/" itemprop="url">
                  Runtime - Message Forwarding
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-26T17:47:36+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在上一篇<a href="https://arkenlee.github.io/2017/02/25/Messaging/">消息发送</a>讲了 Objective-C 的消息发送机制。向对象发送消息时，根据对象的 <code>isa</code> 指针找到所属的类，在类的 <code>methodList</code> 查找对应的方法实现，如果没找到则向父类的 <code>methodList</code> 继续查找。</p>
<p>但如果一直找到根类都没有找到对应的方法会怎样呢？对象调用一个未实现的方法时，并不会因为找不到对应的方法而立即崩溃，而是先经历三个阶段：</p>
<ol>
<li>动态方法解析阶段</li>
<li>备援接收者转发阶段</li>
<li>完整的消息转发阶段</li>
</ol>
<p>如果经过这三个阶段后依旧没能响应方法，那么系统将会执行 <code>doesNotRecognizeSelector:</code> 方法，并抛出异常。</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>当对象调用一个未实现的方法时，runtime 会先尝试调用下面的两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</div></pre></td></tr></table></figure>
<p>如果当前执行的方法是实例方法会调用 <code>resolveInstanceMethod:</code> ，如果是类方法则调用 <code>resolveClassMethod:</code> 。在这两个方法中添加要决定的自定义方法实现，并且当返回 <code>YES</code> 时，runtime 会重新启动一次消息发送的过程。</p>
<p>例如现在有一个 <code>MessageHandler</code> 类，该类有一个实例方法 <code>sendMessage:toReceiver:</code> ，但是在该类的实现中没有对应的方法实现。下面是该类的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MessageHandler</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)sendMessage:(<span class="built_in">NSString</span> *)message toReceiver:(MessageHandler *)receiver;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们知道在 Objective-C 中发送消息，最终会转为 C 语言的 <code>objc_msgSend(receiver, selector, arg1, arg2, …)</code> ，类似的我们也可以自定义一个 C 级别的动态方法实现，并通过 runtime 的 <code>class_addMethod</code> 将方法实现动态添加到类中。</p>
<blockquote>
<p>使用 <code>class_addMethod</code> 函数将会重写父类的方法，但不会改变当前类的现有方法。如果需要改变当前类中的现有方法，可以使用 <code>method_setImplementation</code> 。</p>
</blockquote>
<h3 id="编写动态方法实现函数"><a href="#编写动态方法实现函数" class="headerlink" title="编写动态方法实现函数"></a>编写动态方法实现函数</h3><p>动态方法实现至少需要两个参数：self 和 _cmd。这两个参数是上一篇文章提到的“隐藏”参数。除此之外的参数是方法实现真正需要的参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接口：- (void)sendMessage:(NSString *)message toReceiver:(MessageHandler *)receiver;</span></div><div class="line"><span class="comment">// 动态方法实现</span></div><div class="line"><span class="keyword">void</span> dynamicSendMessageToReceiver(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *message, MessageHandler *receiver)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写消息解析方法"><a href="#重写消息解析方法" class="headerlink" title="重写消息解析方法"></a>重写消息解析方法</h3><p>在 <code>resolveInstanceMethod:</code> 方法中判断如果是 <code>sendMessage:toReceiver:</code> 则动态添加方法实现，如果不是则调用父类的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MessageHandler</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(sendMessage:toReceiver:)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicSendMessageToReceiver, <span class="string">"v@:@@"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>class_addMethod</code> 函数接收四个参数：待添加方法的类、方法名、方法实现指针、方法实现的类型编码（包括返回值编码和参数编码）。</p>
<p> <code>&quot;v@:@@&quot;</code> 是该方法实现的类型编码。其中 <code>v</code> 表示该方法返回类型是 <code>void</code> 。 <code>@:@@</code> 表示接收四个参数，前两个参数即“隐藏”参数—— <code>self</code> 和 <code>_cmd</code> ，类型是对象类型（id）和方法选择器（SEL）；后两个参数都是对象类型，是 <code>sendMessage:toReceiver:</code> 真正需要的参数。</p>
<blockquote>
<p>类型编码的详细描述可参考：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a> </p>
</blockquote>
<h3 id="动态添加方法与内省"><a href="#动态添加方法与内省" class="headerlink" title="动态添加方法与内省"></a>动态添加方法与内省</h3><p>当类通过 <code>class_addMethod</code> 动态添加方法实现后，对实例调用 <code>respondsToSelector:</code> 或者对类调用 <code>instancesRespondToSelector:</code> 均会返回 <code>YES</code> 。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当方法没有对应的方法实现，也没有进行动态方法解析则会触发消息转发机制。</p>
<p>消息转发分为两个阶段：</p>
<ol>
<li>备援接收者转发阶段</li>
<li>完整的消息转发</li>
</ol>
<p>如果响应了备援接收者转发，那么将忽略后面的完整消息转发。如果备援接收者转发和完整消息转发都不能响应方法，那么最后会执行 <code>doesNotRecognizeSelector:</code> 并抛出异常。</p>
<h3 id="备援接收者转发"><a href="#备援接收者转发" class="headerlink" title="备援接收者转发"></a>备援接收者转发</h3><p>以刚才的 <code>MessageHandler</code> 为例，当调用 <code>sendMessage:toReceiver:</code> 方法系统没能找到方法实现时，如果重写了 <code>forwardingTargetForSelector:</code> 方法，那么系统就会在运行时调用这个方法进行备援接收者转发。</p>
<p>该方法返回一个 <code>id</code> 类型的对象，表示系统将会把这个消息转发给其他对象处理。只要这个方法返回的不是 <code>nil</code> 或 <code>self</code> ，也会重新启动一次消息发送的过程。</p>
<p>假设 <code>MessageHelper</code> 类已经实现了 <code>sendMessage:toReceiver:</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MessageHelper</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)sendMessage:(<span class="built_in">NSString</span> *)message toReceiver:(MessageHandler *)receiver;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MessageHelper</span></span></div><div class="line">- (<span class="keyword">void</span>)sendMessage:(<span class="built_in">NSString</span> *)message toReceiver:(MessageHandler *)receiver </div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p> <code>MessageHandler</code> 重写 <code>forwardingTargetForSelector:</code> ，实例对象在调用 <code>sendMessage:toReceiver:</code> 时借由 <code>MessageHelper</code> 类实例处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(sendMessage:toReceiver:)) &#123;</div><div class="line">        <span class="keyword">return</span> [[MessageHelper alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h3><p>在进行完整的消息转发时，系统会先调用 <code>methodSignatureForSelector</code> 返回一个方法签名，用来获取方法的参数和返回值。</p>
<p>如果该方法返回 <code>nil</code> ，那么系统将会执行 <code>doesNotRecognizeSelector:</code> 抛出异常 <code>unrecognized selector sent to instance</code> ；如果该方法返回一个合法的方法签名，系统会创建一个 <code>NSInvocation</code> 对象并调用 <code>forwardInvocation:</code> 方法进行消息转发。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回方法签名</span></div><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (methodSignature == <span class="literal">nil</span>) &#123;</div><div class="line">        methodSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:@@"</span>];</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> methodSignature;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 消息转发</span></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div><div class="line">&#123;</div><div class="line">    MessageHelper *helper = [[MessageHelper alloc] init];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([helper respondsToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:helper];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当进入 <code>forwardInvocation:</code> 时，即使在该方法中不做任何事情，程序也不会崩溃，系统只是把消息转发到该处，至于后续的操作并不关心。</p>
<h3 id="消息转发与内省"><a href="#消息转发与内省" class="headerlink" title="消息转发与内省"></a>消息转发与内省</h3><p>当通过消息转发让实例对象处理对应的消息时，由于在实例对象所属类的方法调度列表中找不到对应的方法实现，所以调用 <code>respondsToSelector:</code> 或者对类调用 <code>instancesRespondToSelector:</code> 会返回 <code>NO</code>。但是可以通过重写这些方法保证对外接口的统一。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(sendMessage:toReceiver:) &amp;&amp;</div><div class="line">            [MessageHelper instancesRespondToSelector:<span class="keyword">@selector</span>(aSelector)]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 其他判断...</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>向对象发送不能处理的消息时，系统在类缓存以及方法调度表中找不到对应的方法实现，此时并不会立即崩溃，而是提供三种方式决定方法的最终调度：</p>
<ol>
<li>在崩溃前系统将进行动态方法解析，如果对象所属的类重写了 <code>resolveInstanceMethod:</code> 或 <code>resolveClassMethod:</code> 方法，那么可以在这些方法中利用 <code>class_addMethod</code> 动态添加方法。</li>
<li>如果在动态方法解析后仍不能响应，那么将进入备援接收者转发阶段，通过 <code>forwardingTargetForSelector:</code> 方法将消息转交给其他对象处理。</li>
<li>如果 <code>forwardingTargetForSelector:</code> 返回 <code>nil</code> 那么将进入完整的消息转发阶段。系统先调用 <code>methodSignatureForSelector:</code> 返回一个方法签名，用来获取方法的参数和返回值。如果该方法返回一个合法的方法签名，系统会创建一个 <code>NSInvocation</code> 对象并调用 <code>forwardInvocation:</code> 方法进行消息转发。如果该方法返回 <code>nil</code>，将会执行 <code>doesNotRecognizeSelector:</code> 并抛出异常。</li>
</ol>
<img src="/2017/02/26/Message-Forwarding/message_forwarding.png" alt="消息转发" title="消息转发">
<p>三种方式比较：</p>
<ul>
<li>动态方法解析：在运行时提供动态添加方法时机，与消息转发机制相比更简单，适合在原始类中扩展功能；</li>
<li>备援接收者转发：与完整的消息转发相比更简单、更迅速，可以将消息转发给其他对象处理，但转发对象数量仅限一个；</li>
<li>完整消息转发：与备援接收者转发更复杂，但可以将消息转发给多个对象，可以模拟多继承效果。</li>
</ul>
<p>消息转发的步骤越往后，其代价越大。如果消息在动态方法解析阶段就能处理，那么在运行期系统就会将方法缓存起来，下次调用的时候就直接调用方法，而不触发消息转发。如果进入到消息转发阶段，消息能被备援接收者处理，就无需创建完整的 <code>NSInvocation</code> ，令消息处理过程更为简单。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">[1] Objective-C Runtime Programming Guide - Dynamic Method Resolution</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">[2] Objective-C Runtime Programming Guide - Message Forwarding</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">[3] Objective-C Runtime Programming Guide - Type Encodings</a></p>
<p>[4] Matt Galloway. Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法（爱飞翔 译）[M]. 北京: 机械工业出版社, 2014.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/02/25/Messaging/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Messaging/" itemprop="url">
                  Runtime - Messaging
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-25T23:22:27+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>runtime 是系统在运行的时候的一些机制，Objective-C 代码在程序运行时最终是转成了运行时代码。其中 runtime 在 Objective-C 中最重要的一个特性就是<strong>消息机制</strong>。对于 C 语言而言，函数的调用在编译的时候就已经确定了。Objective-C 在编译的时候并不决定真正调用哪个函数，而是在运行时才会去查找所要执行的方法，只要声明就不会报错。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>在 Objective-C 中，调用某个方法并不是像 C 语言那样<strong>调用函数</strong>，而是说<strong>向对象发送消息</strong>，代码 <code>[receiver message]</code> 表示“向 receiver 对象发送 message 消息“。</p>
<p>消息在运行时之前不绑定到方法实现，编译器只是转换为消息表达，在运行时的时候再去寻找对应方法的实现并执行。</p>
<h3 id="消息转换"><a href="#消息转换" class="headerlink" title="消息转换"></a>消息转换</h3><p>在 Objective-C 中，向对象发送一个消息是以一对方括号<code>[]</code>表示，例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OC 调用方法</span></div><div class="line">[receiver message];</div></pre></td></tr></table></figure></p>
<p>该代码在 runtime 中转为 C 语言的 <code>objc_msgSend</code> 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转为 C 语言函数</span></div><div class="line">objc_msgSend(receiver, selector);</div></pre></td></tr></table></figure></p>
<p>在 <code>objc/message.h</code>中可以看到该函数的声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p><code>objc_msgSend</code>中有两个重要的参数：消息接收者（id 类型）和方法名（方法选择器）。由于这两个参数没有在定义方法的源码中声明，因此也称为“隐藏”参数。函数后面的省略号则表示发送消息的参数。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OC 的方法</span></div><div class="line">[receiver messageWithArg1:arg1 arg2:arg2];</div><div class="line"></div><div class="line"><span class="comment">// 转为 C 语言的方法</span></div><div class="line">objc_msgSend(receiver, <span class="keyword">@selector</span>(messageWithArg1:arg2:), arg1, arg2);</div></pre></td></tr></table></figure></p>
<p>虽然“隐藏”参数没有显示声明，但我们仍然可以使用，通过 <code>self</code> 关键词引用当前的消息接收者，通过 <code>_cmd</code> 引用当前的方法选择器<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- strange &#123;</div><div class="line">    <span class="keyword">id</span>  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用 <code>objc_msgSend</code> 后，又是怎么找到对应的方法实现并且执行它呢？在说明这个问题之前先了解一下 Objective-C 中类和方法的结构。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Cocoa 框架的绝大部分类都是继承自 <code>NSObject</code> 类（也有例外，如：<code>NSProxy</code> 类），进入 <code>objc/NSObject.h</code> 可以看到 <code>NSObject</code> 的结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>NSObject</code> 中有一个 <code>Class</code> 类型的 <code>isa</code> 指针，这意味着每一个 <code>NSObject</code> 的实例都有一个 <code>isa</code> 指针变量。进入 <code>objc/objc.h</code> 查看 <code>Class</code> 的定义可以发现，它是结构体 <code>objc_class</code> 指针的别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>再进入 <code>objc/runtime.h</code> 可以看到结构体 <code>objc_class</code> 的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>可以知道：实例对象都有一个 <code>isa</code> 指针，该指针指向了结构体 <code>objc_class</code> 。而 <code>objc_class</code> 除了成员方法列表外，还可以看到父类指针、类名、成员变量列表等一系列描述该类实例的特征。同时还包括类的 <code>isa</code> 指针，这个 <code>isa</code> 指针又指向哪里呢？</p>
<p>对于 Objective-C 这门面向对象语言来说一切皆对象，就连类本身也不例外，实际上 Objective-C 也确实是这么做的。每个实例通过 <code>isa</code> 指向了描述该<strong>类实例特征</strong>的结构体，而类对象通过 <code>isa</code> 指针指向了描述<strong>类静态特征</strong>的结构体，这个结构体称之为元类（meta class），换言之，类对象就是元类的实例。元类结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/// A pointer to an instance of a class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</div></pre></td></tr></table></figure></p>
<p>因此在 Objective-C 的内部，每一个实例对象通过 <code>isa</code> 指针指向它的类对象，类对象通过 <code>super_class</code> 指向它的父类对象，顺着这个 <code>super_class</code> 指针一直指向根类 <code>NSObject</code> 。</p>
<p>而类对象的 <code>isa</code> 则指向它的元类，元类的 <code>isa</code> 指针则直接指向了根类 <code>NSObject</code> 的元类。而 <code>NSObject</code> 的元类的 <code>isa</code> 指针指向了 <code>NSObject</code> 类本身。下图表示了它们之间的关系：</p>
<img src="/2017/02/25/Messaging/class_isa.png" alt="isa 指针以及 superclass 指针的关系" title="isa 指针以及 superclass 指针的关系">
<blockquote>
<p>值得注意的是，在官方关于 <code>KVO</code> 的文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Key-Value Observing Implementation Details</a> 中提到：<code>KVO</code> 是通过 <code>isa-swizzling</code> 实现的。即 <code>isa</code> 指针在运行时会被修改为指向一个 <code>NSKVONotifying_</code> 前缀的派生类，而非真正的类。因此在 Objective-C 中最好不要通过 <code>isa</code> 指针来确定所属类，而是通过 <code>class</code> 方法来确定。</p>
<p>对于 <code>NSObject</code> 及其子类可以通过 <code>isKindOfClass:</code> 和 <code>isMemberOfClass:</code> 这些内省方法方便且安全的判断实例的所属类和继承链。</p>
</blockquote>
<p>在结构体 <code>objc_class</code> 中可以看到一个二级指针的 <code>methodLists</code> 方法调度表，这个列表就储存了当前类的成员方法信息（不包括父类）。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>调度表 <code>methodLists</code> 的结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_method_list &#123;</div><div class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>列表的每个结点是一个描述方法的结构体，也就是 Objective-C 中的“方法”的基本单元—<code>objc_method</code> ，在 <code>objc/runtime.h</code> 中可以看到相关定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p> <code>method_name</code> 就是方法名，其类型是 <code>SEL</code>，它是一个 int 类型的地址，地址中存放着方法名。一个方法对应着一个 <code>SEL</code>，即不会存在两个名字相同的方法，即使参数类型不同。通过 <code>@selector</code> 可获取。在 <code>objc/objc.h</code> 中可以看到 <code>SEL</code> 是结构体 <code>objc_selector</code> 指针的别名：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method selector.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>method_imp</code> 是方法实现的指针，其类型是 <code>IMP</code>，可理解为函数指针，指向方法实现的目标函数。在 <code>objc/objc.h</code> 中可以看到 <code>IMP</code> 的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>因此，只要通过对应的 <code>method_name</code> 找到这个方法，并且调用这个方法的 <code>method_imp</code> 就可以执行目标函数。</p>
<h3 id="方法调度"><a href="#方法调度" class="headerlink" title="方法调度"></a>方法调度</h3><p>回到最开始的问题，objc_msgSend 后怎么找到对应的方法实现并且执行它呢？实际上就是根据该函数的两个“隐藏”参数 receiver（方法接收者）和 selector（方法名）查找。</p>
<p>首先通过 receiver 的 <code>isa</code> 指针找到所属类，在所属类的 <code>methodLists</code> 中通过 selector 查找是否有对应的方法。</p>
<p>如果在所属类找不到，则顺着 <code>super_class</code> 指针在父类的 <code>methodList</code> 中查找，直到根类。</p>
<p>一旦找到匹配的方法，那么就调用方法的 <code>method_imp</code> 执行目标函数，从而达到执行方法的效果。</p>
<img src="/2017/02/25/Messaging/search_selector.png" alt="查找方法" title="查找方法">
<h3 id="消息缓存"><a href="#消息缓存" class="headerlink" title="消息缓存"></a>消息缓存</h3><p>每次向一个对象发送消息时都要在继承链中查找一次吗？答案是否定的。</p>
<p>回到结构体 <code>objc_class</code> 的定义，有个 <code>struct objc_cache *</code> 类型的 <code>cache</code> 指针。在 <code>objc/runtime.h</code> 中可以找到这个 <code>objc_cache</code> 的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache    OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个结构体就是关于方法的缓存链表，在发送消息时，先从这个方法缓存里查找，如果找不到再遵循 <code>isa</code> 指针方式查找 <code>methodList</code> 。在第一次查找到方法后，就会把这个方法放到缓存里，以便下次查找的时候可以快速定位方法实现。</p>
<blockquote>
<p>objc_cache 结构体字段描述：</p>
<p>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</p>
<p>occupied：一个整数，指定实际占用的缓存bucket的总数。</p>
<p>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</p>
<p>参考 <a href="http://www.cocoachina.com/ios/20141031/10105.html" target="_blank" rel="external">Objective-C Runtime 运行时之一：类与对象</a></p>
</blockquote>
<h3 id="向-super-发送消息"><a href="#向-super-发送消息" class="headerlink" title="向 super 发送消息"></a>向 super 发送消息</h3><p>在使用 Objective-C 开发的过程中，有时会使用 <code>super</code> 关键词，那么在向 <code>super</code> 发送消息时会发生什么事情呢？比如在常见的 <code>init</code> 方法中调用 <code>[super init]</code> ：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与“隐藏”参数 <code>self</code> 不同，<code>super</code> 实际上只是一个<strong>编译器标识符</strong>，负责告诉编译器在调用方法时，跳过当前类去调用父类的方法，而不是本类中的方法。</p>
<p>在消息转化时，并不是转为 <code>objc_msgSend</code> 而是调用另外一个 <code>objc_msgSendSuper</code> 方法，并且传递给该方法的第一个参数是一个 <code>objc_super</code> 结构体指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">id <span class="title">objc_msgSendSuper</span> <span class="params">( <span class="keyword">struct</span> objc_super *super, SEL op, ... )</span></span>;</div></pre></td></tr></table></figure></p>
<p>结构体 <code>objc_super</code> 定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Specifies the superclass of an instance. </span></div><div class="line"><span class="keyword">struct</span> objc_super &#123;</div><div class="line">    <span class="comment">/// Specifies an instance of a class.</span></div><div class="line">    __unsafe_unretained id receiver;</div><div class="line"></div><div class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></div><div class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></div><div class="line">    __unsafe_unretained Class <span class="keyword">class</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    __unsafe_unretained Class super_class;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* super_class is the first class to search */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在调用 <code>objc_msgSendSuper</code> 时，编译器构造出 <code>objc_super</code> 结构体，第一个成员依旧是本消息接受者即 <code>self</code> ，第二个参数是父类。因此在向 <code>super</code> 发送 <code>init</code> 消息 <code>[super init]</code>，会大致转化为如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取父类</span></div><div class="line">Class super_cls = class_getSuperclass(object_getClass(self));</div><div class="line"></div><div class="line"><span class="comment">// 构造结构体</span></div><div class="line"><span class="keyword">struct</span> objc_super super_obj = &#123;self, super_cls&#125;;</div><div class="line"><span class="keyword">struct</span> objc_super *super_prt = &amp;super_obj;</div><div class="line"></div><div class="line"><span class="comment">// 转为 C 消息函数</span></div><div class="line">objc_msgSendSuper(super_prt, @selector(init));</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Objective-C 中向对象发送消息 <code>[receiver message]</code> 时并不会立即执行，而是由编译器转换为消息表达，延迟到运行时再做处理：</p>
<ol>
<li>将 <code>[receiver message]</code> 转为 <code>objc_msgSend(receiver, @selector(message))</code> ；</li>
<li>在运行时通过 <code>receiver</code> 的 <code>isa</code> 指针找到所属 <code>class</code> ；</li>
<li>在 <code>class</code> 的 <code>cache</code> 里查找 <code>message</code> 方法；</li>
<li>如果在 <code>cache</code> 中找不到，那么从 <code>methodList</code> 中继续查找；</li>
<li>如果在当前 <code>class</code> 中找不到，那么顺着 <code>super_class</code> 指向的继承链逐级查找；</li>
<li>一旦找到 <code>message</code> 对应的方法，那么调用 <code>method_imp</code> 执行目标函数。</li>
</ol>
<p>每个方法都有两个隐藏参数：self 和 _cmd。分别表示当前消息接受者和当前方法选择器。</p>
<p>向 <code>super</code> 发送消息是，会转为 <code>objc_msgSendSuper ( struct objc_super *super, SEL op, … )</code> </p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在 Objective-C 中向对象发送消息，都会变为<code>查找方法-&gt;执行</code> ，如果某个方法被连续执行多次，那么查找方法时的额外开销将会不断累积。</p>
<p>想要避免 runtime 的方法动态绑定，其唯一途径是获取到方法的地址即 <code>IMP</code> ，并且直接调用它。在 <code>NSObject</code> 中可以找到两个可以获取 <code>IMP</code> 的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (IMP)methodForSelector:(SEL)aSelector;</div><div class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</div></pre></td></tr></table></figure></p>
<p>可以通过 <code>-methodForSelector:</code> 或者 <code>+instanceMethodForSelector:</code> 规避方法动态绑定，从而节省消息传递时所花费的额外时间。</p>
<p>例如，我们要对 <code>target</code> 发送消息 <code>setFilled</code> 表示目标已经装满：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[target setFilled:<span class="literal">YES</span>]; <span class="comment">// 或 target.filled = YES;</span></div></pre></td></tr></table></figure></p>
<p>如果我们对包含 10000 个目标的列表中的每个 <code>target</code> 都调用一次 <code>setFilled</code> 会如何？</p>
<p>在第一次调用 <code>setFilled</code> 的时候会在 <code>target</code> 所属类或父类的 <code>methodList</code> 找到对应的方法，并且把方法放入 <code>cache</code> 中缓存，往后的 9999 次操作则从 <code>cache</code> 查找方法并执行。</p>
<p>如果我们可以一次性找到 <code>setFilled</code> 方法实现的地址，并且直接调用它，那么将会省略后面的消息转化和 <code>cache</code> 查找：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;Target *&gt; *targetList = ...; <span class="comment">// 包含1000个目标的列表</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[Target</div><div class="line">    instanceMethodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++ )</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="external">[1] Objective-C Runtime Programming Guide - Messaging</a><br><a href="http://www.cocoachina.com/ios/20141031/10105.html" target="_blank" rel="external">[2] Objective-C Runtime 运行时之一：类与对象</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/icon.JPG"
               alt="Lee" />
          <p class="site-author-name" itemprop="name">Lee</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/arKenLee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
