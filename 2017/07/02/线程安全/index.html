<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="线程锁,线程安全," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="线程安全在 iOS 开发过程中经常会使用多线程处理耗时操作，在不同线程对同一个数据进行操作时，不可避免的就会出现数据不一致的情况。尤其是单例模式，由于全局仅有一个实例，在不同线程中改写单例的数据是非常危险的。为了避免这种情况通常可以采用加锁、使用信号量或者使用队列来保证线程的安全。
线程锁线程锁按功能划分可以分为：互斥锁、自旋锁、条件锁、递归锁、分布锁等，按照不同用途可以采用合适的锁。
OC层面常">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全">
<meta property="og:url" content="https://arKenLee.github.io/2017/07/02/线程安全/index.html">
<meta property="og:site_name" content="Ken’s Notes">
<meta property="og:description" content="线程安全在 iOS 开发过程中经常会使用多线程处理耗时操作，在不同线程对同一个数据进行操作时，不可避免的就会出现数据不一致的情况。尤其是单例模式，由于全局仅有一个实例，在不同线程中改写单例的数据是非常危险的。为了避免这种情况通常可以采用加锁、使用信号量或者使用队列来保证线程的安全。
线程锁线程锁按功能划分可以分为：互斥锁、自旋锁、条件锁、递归锁、分布锁等，按照不同用途可以采用合适的锁。
OC层面常">
<meta property="og:updated_time" content="2018-03-14T15:34:40.702Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程安全">
<meta name="twitter:description" content="线程安全在 iOS 开发过程中经常会使用多线程处理耗时操作，在不同线程对同一个数据进行操作时，不可避免的就会出现数据不一致的情况。尤其是单例模式，由于全局仅有一个实例，在不同线程中改写单例的数据是非常危险的。为了避免这种情况通常可以采用加锁、使用信号量或者使用队列来保证线程的安全。
线程锁线程锁按功能划分可以分为：互斥锁、自旋锁、条件锁、递归锁、分布锁等，按照不同用途可以采用合适的锁。
OC层面常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://arKenLee.github.io/2017/07/02/线程安全/"/>





  <title> 线程安全 | Ken’s Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ken’s Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep Calm and Carry On</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://arKenLee.github.io/2017/07/02/线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken’s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                线程安全
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T11:48:52+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Thread/" itemprop="url" rel="index">
                    <span itemprop="name">Thread</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在 iOS 开发过程中经常会使用多线程处理耗时操作，在不同线程对同一个数据进行操作时，不可避免的就会出现数据不一致的情况。尤其是单例模式，由于全局仅有一个实例，在不同线程中改写单例的数据是非常危险的。为了避免这种情况通常可以采用加锁、使用信号量或者使用队列来保证线程的安全。</p>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>线程锁按功能划分可以分为：互斥锁、自旋锁、条件锁、递归锁、分布锁等，按照不同用途可以采用合适的锁。</p>
<p>OC层面常见的6个锁：NSLock、NSRecursiveLock、NSCondition、NSConditionLock、@synchronized、NSDistributedLock。</p>
<p>C语言层面常见的锁：OSSpinLock、pthread_mutex、pthread_spin、pthread_con、pthread_rwlock。</p>
<h3 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h3><h4 id="1-NSLock"><a href="#1-NSLock" class="headerlink" title="1.NSLock"></a>1.NSLock</h4><p><code>NSLock</code> 是OC层面的锁，继承自 <code>NSObject</code>，创建和使用都非常简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">[lock lock];</div><div class="line">// do something</div><div class="line">[lock unlock];</div></pre></td></tr></table></figure>
<h4 id="2-NSLock-IMP"><a href="#2-NSLock-IMP" class="headerlink" title="2.NSLock + IMP"></a>2.NSLock + IMP</h4><p>使用 <code>NSLock</code> 时可以直接取出加锁和解锁的 <code>IMP</code> 直接执行，效率比直接使用方法略高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef void (*func)(id, SEL);</div><div class="line"></div><div class="line">NSLock *lock = [[NSLock alloc] init];</div><div class="line"></div><div class="line">SEL lockSEL = @selector(lock);</div><div class="line">SEL unlockSEL = @selector(unlock);</div><div class="line"></div><div class="line">func lockFunc = (void (*)(id, SEL))[lock methodForSelector:lockSEL];</div><div class="line">func unlockFunc = (void (*)(id, SEL))[lock methodForSelector:unlockSEL];</div><div class="line"></div><div class="line">lockFunc(lock, lockSEL);</div><div class="line">// do something</div><div class="line">unlockFunc(lock, unlockSEL)</div></pre></td></tr></table></figure>
<h4 id="3-synchronized"><a href="#3-synchronized" class="headerlink" title="3.@synchronized"></a>3.@synchronized</h4><p>这个是Objective-C语法级的锁，简单易用，但性能较差</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@synchronized(self) &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-Pthread-mutex"><a href="#4-Pthread-mutex" class="headerlink" title="4.Pthread mutex"></a>4.Pthread mutex</h4><p>C级别的锁，从 2.6.x 系列稳定版内核开始<br>需要引入头文件： <code>#include &lt;pthread.h&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// --------- 作为变量使用 ---------</div><div class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;mutex);</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line"></div><div class="line">// --------- 作为属性使用 ---------</div><div class="line">// 如果作为属性，不能用该宏来初始化</div><div class="line">pthread_mutex_init(&amp;_mutex, NULL);</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;_mutex);</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;_mutex);</div><div class="line"></div><div class="line">// 对象销毁时要把锁销毁</div><div class="line">pthread_mutex_destroy(&amp;_mutex);</div><div class="line"></div><div class="line"></div><div class="line">// --------- Swift 中使用 pthread_mutex ---------</div><div class="line">var lock = pthread_mutex_t()</div><div class="line"></div><div class="line">pthread_mutex_init(&amp;lock, nil)</div><div class="line"></div><div class="line">pthread_mutex_lock(&amp;lock)</div><div class="line">// do something</div><div class="line">pthread_mutex_unlock(&amp;lock)</div><div class="line"></div><div class="line">pthread_mutex_destroy(&amp;lock)</div></pre></td></tr></table></figure>
<h4 id="5-NSCondition"><a href="#5-NSCondition" class="headerlink" title="5.NSCondition"></a>5.NSCondition</h4><p>NSCondition 是互斥锁和条件锁的结合，实际上作为一个锁和一个线程检查器：锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞</p>
<p>NSCondition 的几个方法：</p>
<ul>
<li>-lock: 其他线程命令在lock外等待</li>
<li>-unlock: 解除锁</li>
<li>-wait: 让当前线程处于等待状态</li>
<li>-waitUntilDate: 等待一段时间</li>
<li>-signal: CPU 发信号任意通知线程不用等待可以继续执行</li>
<li>broadcast: CPU 通知所有等待的线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">_myCondition = [[NSCondition alloc] init];</div><div class="line"></div><div class="line">- (void)method1 &#123;</div><div class="line">    NSLog(@&quot;Starting method1&quot;);</div><div class="line">    NSLog(@&quot;Will lock method1&quot;);</div><div class="line"></div><div class="line">    [_myCondition lock];</div><div class="line"></div><div class="line">    NSLog(@&quot;Did lock method1&quot;);</div><div class="line"></div><div class="line">    while (!_someCheckIsTrue) &#123;</div><div class="line">        NSLog(@&quot;Will wait method1&quot;);</div><div class="line">        [_myCondition wait];</div><div class="line">        NSLog(@&quot;Did wait method1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSLog(@&quot;Will unlock method1&quot;);</div><div class="line"></div><div class="line">    [_myCondition unlock];</div><div class="line"></div><div class="line">    NSLog(@&quot;Did unlock method1&quot;);</div><div class="line">    NSLog(@&quot;Ending method1&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)method2 &#123;</div><div class="line">    NSLog(@&quot;Starting method2&quot;);</div><div class="line">    NSLog(@&quot;Will lock method2&quot;);</div><div class="line">  </div><div class="line">    [_myCondition lock];</div><div class="line">  </div><div class="line">    NSLog(@&quot;Did lock method2&quot;);</div><div class="line"></div><div class="line">    _someCheckIsTrue = YES;</div><div class="line"></div><div class="line">    NSLog(@&quot;Will signal method2&quot;);</div><div class="line"></div><div class="line">    [_myCondition signal];</div><div class="line"></div><div class="line">    NSLog(@&quot;Did signal method2&quot;);</div><div class="line">    NSLog(@&quot;Will unlock method2&quot;);</div><div class="line"></div><div class="line">    [_myCondition unlock];</div><div class="line"></div><div class="line">    NSLog(@&quot;Did unlock method2&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后打印结果依次是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. Starting method1</div><div class="line">2. Will lock method1</div><div class="line">3. Did lock method1</div><div class="line">4. Will wait method1</div><div class="line">5. Starting method2</div><div class="line">6. Will lock method2</div><div class="line">7. Did lock method2</div><div class="line">8. Will signal method2</div><div class="line">9. Did signal method2</div><div class="line">10. Will unlock method2</div><div class="line">11. Did wait method1</div><div class="line">12. Did unlock method2</div><div class="line">13. Will unlock method1</div><div class="line">14. Did unlock method1</div><div class="line">15. Ending method1</div></pre></td></tr></table></figure>
<h3 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h3><h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>需要引入头文件：<code>#include &lt;libkern/OSAtomic.h&gt;</code><br>C级别的自旋锁，不过由于OSSpinLock有点问题，可以使用 pthread_mutex 替代，苹果内部目前的锁大多数都替换为这个，并且进行了优化，效率接近自旋锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">OSSpinLock spinLock = OS_SPINLOCK_INIT;</div><div class="line"></div><div class="line">OSSpinLockLock(&amp;spinLock);</div><div class="line">// do something</div><div class="line">OSSpinLockUnlock(&amp;spinLock);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// Swift 中使用 OSSpinLock</div><div class="line">var spinLock = OS_SPINLOCK_INIT</div><div class="line"></div><div class="line">OSSpinLockLock(&amp;spinLock)</div><div class="line">// do something</div><div class="line">OSSpinLockUnlock(&amp;spinLock)</div></pre></td></tr></table></figure>
<blockquote>
<p>不再安全的OSSpinLock: <a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/</a></p>
</blockquote>
<h3 id="条件锁（Condition-Lock）"><a href="#条件锁（Condition-Lock）" class="headerlink" title="条件锁（Condition Lock）"></a>条件锁（Condition Lock）</h3><h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>为了方便对某个线程可能只对某个条件的锁感兴趣，可以通过条件来获取锁的状态。最常见的应用是生产者、消费者模型中消费者关心的 NSConditionLock 通过 condition 属性来判别条件是否成立。</p>
<p><code>NSConditionLock</code> 的属性及方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 这属性非常重要，外部传入的condition与之相同才会获取到lock对象，反之阻塞当前线程，直到condition相同</div><div class="line">@property (readonly)NSInteger condition; </div><div class="line"></div><div class="line">// 指定初始化方法</div><div class="line">- (instancetype)initWithCondition:(NSInteger)conditionNS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">// NSLocking 的两个方法</div><div class="line">- (void)lock;</div><div class="line">- (void)unlock;</div><div class="line"></div><div class="line">// condition与内部相同才会获取锁对象并立即返回，否则阻塞线程直到condition相同</div><div class="line">- (void)lockWhenCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">// 尝试获取锁对象，获取成功需要配对unlock</div><div class="line">- (BOOL)tryLock;</div><div class="line"></div><div class="line">//同上</div><div class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">//解锁，并且设置lock.condition = condition</div><div class="line">- (void)unlockWithCondition:(NSInteger)condition; </div><div class="line"></div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)executeLock &#123;</div><div class="line">    NSConditionLock* lock = [[NSConditionLock alloc] init];</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        for (NSUInteger i=0; i&lt;3; i++) &#123;</div><div class="line">            sleep(2);</div><div class="line">            if (i == 2) &#123;</div><div class="line">                [lock lock];</div><div class="line">                [lock unlockWithCondition:i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        sleep(1);</div><div class="line">        [self threadMethod:lock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        sleep(1);</div><div class="line">        [self threadMethod:lock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)threadMethod:(NSConditionLock *)lock &#123;</div><div class="line">    [lock lockWhenCondition:2];</div><div class="line">    [lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归锁（Recursive-Lock）"><a href="#递归锁（Recursive-Lock）" class="headerlink" title="递归锁（Recursive Lock）"></a>递归锁（Recursive Lock）</h3><h4 id="1-NSRecursiveLock"><a href="#1-NSRecursiveLock" class="headerlink" title="1.NSRecursiveLock"></a>1.NSRecursiveLock</h4><p>避免在同一线程中多次获取该锁（lock会造成等待锁的unlock，如果加上trylock则不存在问题）导致的死锁问题，使用 <code>NSRecursiveLock</code> 就可以在同一线程中多次加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^RecursiveBlock)(int);</div><div class="line"></div><div class="line">    RecursiveBlock = ^(int value) &#123;</div><div class="line">        [lock lock];</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            sleep(2);</div><div class="line">            RecursiveBlock(value - 1);</div><div class="line">        &#125;</div><div class="line">        [lock unlock];</div><div class="line">    &#125;;</div><div class="line">    RecursiveBlock(5);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    sleep(2);</div><div class="line">    </div><div class="line">    BOOL flag = [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:1]];</div><div class="line">    if (flag) &#123;</div><div class="line">        NSLog(@&quot;lock before date&quot;);</div><div class="line">        [lock unlock];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;fail to lock before date&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. value = 5</div><div class="line">2. value = 4</div><div class="line">3. fail to lock before date</div><div class="line">4. value = 3</div><div class="line">5. value = 2</div><div class="line">6. value = 1</div></pre></td></tr></table></figure>
<h4 id="2-pthread-mutex-recursive"><a href="#2-pthread-mutex-recursive" class="headerlink" title="2.pthread_mutex(recursive)"></a>2.pthread_mutex(recursive)</h4><p>需要引入头文件：<code>#include &lt;pthread.h&gt;</code></p>
<p>通过 pthread_mutexattr 将锁设置为递归锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_t lock;</div><div class="line">pthread_mutexattr_t attr;</div><div class="line"></div><div class="line">pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认</div><div class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁</div><div class="line"></div><div class="line">pthread_mutex_init(&amp;lock, &amp;attr);</div><div class="line">pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void(^RecursiveBlock)(int);</div><div class="line"></div><div class="line">    RecursiveBlock = ^(int value) &#123;</div><div class="line">        pthread_mutex_lock(&amp;lock);</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            NSLog(@&quot;value = %d&quot;, value);</div><div class="line">            RecursiveBlock(value - 1);</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;lock);</div><div class="line">    &#125;;</div><div class="line">    RecursiveBlock(5);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. value = 5</div><div class="line">2. value = 4</div><div class="line">3. value = 3</div><div class="line">4. value = 2</div><div class="line">5. value = 1</div></pre></td></tr></table></figure>
<h3 id="读写锁（Read-write-Lock）"><a href="#读写锁（Read-write-Lock）" class="headerlink" title="读写锁（Read-write Lock）"></a>读写锁（Read-write Lock）</h3><h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><p>需要引入头文件：<code>#include &lt;pthread.h&gt;</code><br>效率比递归锁差，比条件锁好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)initLock &#123;</div><div class="line">    pthread_rwlock_init(&amp;_rwlock, NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 写加锁</div><div class="line">-(void)writingLock:(NSString *)temp &#123;</div><div class="line">    pthread_rwlock_wrlock(&amp;_rwlock);</div><div class="line">    // writing</div><div class="line">    self.rwStr = temp;</div><div class="line">    NSLog(@&quot;%@&quot;, temp);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 读加锁</div><div class="line">- (NSString *)readingLock &#123;</div><div class="line">    pthread_rwlock_rdlock(&amp;_rwlock);</div><div class="line">    // reading</div><div class="line">    NSString *str = self.rwStr;</div><div class="line">    NSLog(@&quot;reading = %@&quot;,self.rwStr);</div><div class="line">    pthread_rwlock_unlock(&amp;_rwlock);</div><div class="line">    return str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分布锁（Didtributed-Lock）"><a href="#分布锁（Didtributed-Lock）" class="headerlink" title="分布锁（Didtributed Lock）"></a>分布锁（Didtributed Lock）</h3><h4 id="NSDistributedLock（macOS）"><a href="#NSDistributedLock（macOS）" class="headerlink" title="NSDistributedLock（macOS）"></a>NSDistributedLock（macOS）</h4><p>如果是Mac开发，除了解决多线程冲突外，还需要解决进程间的冲突。跨进程的分布式锁，是进程间同步的工具，底层是用文件系统实现的互斥锁，并不强制进程休眠，而是起到告知的作用。</p>
<p><code>NSDistributedLock</code> 没有实现 <code>NSLocking</code> 协议，所以没有会阻塞线程的 <code>-lock</code>方法，取而代之的是非阻塞的<code>-tryLock</code> 方法来获取锁，用<code>-unlock</code> 方法释放锁。</p>
<p>如果一个获取锁的进程在释放锁之前就退出了，那么锁就一直不能释放，此时可以通过 <code>-breakLock</code> 强行获取锁。</p>
<p><code>NSDistributedLock</code> 的初始化方法需要一个文件或文件夹路径，如果路径目标文件或文件夹不存在，那么在 <code>-tryLock</code> 返回 <code>YES</code> 时，系统会自动创建该文件或文件夹，在结束时该文件或文件夹会被清除,因此可以选择一个不存在的路径防止系统误删文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// app 1</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    _lock = [[NSDistributedLock alloc] initWithPath:@&quot;a path&quot;];</div><div class="line">    [_lock breakLock];</div><div class="line">    [_lock tryLock];</div><div class="line">    sleep(1);</div><div class="line">    [_lock unlock];</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// app2</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    _lock = [[NSDistributedLock alloc] initWithPath:@&quot;a path&quot;];</div><div class="line">    while (![_lock tryLock]) &#123;</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">    [_lock unlock];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>除了使用线程锁保证线程安全外，通过GCD也可以达到同样的效果。</p>
<h3 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore 信号量"></a>dispatch_semaphore 信号量</h3><p>通过信号量的增减来保证线程安全，信号量在初始化的时候决定，当信号量为0时阻塞当前线程，大于1时继续运行：</p>
<ul>
<li>使用 <code>dispatch_semaphore_wait</code> 方法让信号量-1，达到 lock 的效果</li>
<li>通过 <code>dispatch_semaphore_signal</code> 让信号量+1，达到 unlock 的效果</li>
</ul>
<p>初始信号量为0，通过overTime让其继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//传入值必须 &gt;=0, 若传入为0则阻塞线程并等待timeout,时间到后会执行其后的语句</div><div class="line">dispatch_semaphore_t dsema = dispatch_semaphore_create(0); </div><div class="line"></div><div class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    dispatch_semaphore_wait(dsema, overTime); //signal 值 -1</div><div class="line">    // do somethine</div><div class="line">    dispatch_semaphore_signal(dsema); //signal 值 +1</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    dispatch_semaphore_wait(dsema, overTime);</div><div class="line">    // do something</div><div class="line">    dispatch_semaphore_signal(dsema);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>初始信号量为1，等待时间为 DISPATCH_TIME_FOREVER，根据信号量实现线程安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line"></div><div class="line">dispatch_semaphore_t dsema = dispatch_semaphore_create(1);</div><div class="line"></div><div class="line">NSMutableArray *array = [NSMutableArrayarray];</div><div class="line"></div><div class="line">for (int index = 0; index &lt; 100000; index++) &#123;</div><div class="line"></div><div class="line">    dispatch_async(queue, ^()&#123;</div><div class="line"></div><div class="line">        dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);</div><div class="line">        NSLog(@&quot;add :%d&quot;, index);</div><div class="line">        [array addObject:[NSNumber numberWithInt:index]];</div><div class="line">        dispatch_semaphore_signal(dsema);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Barrier-栅栏"><a href="#Barrier-栅栏" class="headerlink" title="Barrier 栅栏"></a>Barrier 栅栏</h3><p>并发队列的栅栏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)initQueue &#123;</div><div class="line">    _queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getter</div><div class="line">- (NSData *)getter &#123;</div><div class="line">    __block NSData *result = nil;</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">         result = ...;</div><div class="line">    &#125;);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// setter</div><div class="line">- (void)setterWithData:(NSData *)data &#123;</div><div class="line">    dispatch_barrier_sync(_queue, ^&#123;</div><div class="line">         // ...</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    // 如果写操作是比较耗时的，可以采用异步栅栏，比如写文件操作</div><div class="line">    // 如果操作不耗时，用同步栅栏会比异步栅栏快是因为异步执行时，需要拷贝块</div><div class="line">    // 如果拷贝块的时间超过执行时间，那么异步会比较慢</div><div class="line">//    dispatch_barrier_async(_queue, ^&#123;</div><div class="line">//         ...</div><div class="line">//    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Serial-Queue-串行队列"><a href="#Serial-Queue-串行队列" class="headerlink" title="Serial Queue 串行队列"></a>Serial Queue 串行队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)initQueue &#123;</div><div class="line">    _queue = dispatch_queue_create(&quot;com.company.app.syncQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getter</div><div class="line">- (NSData *)getter &#123;</div><div class="line">    __block NSData *result = nil;</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">        result = ...;</div><div class="line">    &#125;);</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// setter</div><div class="line">- (void)setterWithData:(NSData *)data &#123;</div><div class="line">    // 如果写操作是比较耗时的，可以采用异步执行，理由见上</div><div class="line">    dispatch_sync(_queue, ^&#123;</div><div class="line">        // ...</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/线程锁/" rel="tag"># 线程锁</a>
          
            <a href="/tags/线程安全/" rel="tag"># 线程安全</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/30/AVPlayer-iOS在线播放/" rel="next" title="AVPlayer">
                <i class="fa fa-chevron-left"></i> AVPlayer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/24/In-App-Purchase/" rel="prev" title="In-App Purchase">
                In-App Purchase <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/icon.JPG"
               alt="Lee" />
          <p class="site-author-name" itemprop="name">Lee</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/arKenLee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程锁"><span class="nav-number">2.</span> <span class="nav-text">线程锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁（Mutex）"><span class="nav-number">2.1.</span> <span class="nav-text">互斥锁（Mutex）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-NSLock"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.NSLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-NSLock-IMP"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.NSLock + IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-synchronized"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.@synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Pthread-mutex"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.Pthread mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-NSCondition"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.NSCondition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁（Spin-Lock）"><span class="nav-number">2.2.</span> <span class="nav-text">自旋锁（Spin Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSSpinLock"><span class="nav-number">2.2.1.</span> <span class="nav-text">OSSpinLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件锁（Condition-Lock）"><span class="nav-number">2.3.</span> <span class="nav-text">条件锁（Condition Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSConditionLock"><span class="nav-number">2.3.1.</span> <span class="nav-text">NSConditionLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归锁（Recursive-Lock）"><span class="nav-number">2.4.</span> <span class="nav-text">递归锁（Recursive Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-NSRecursiveLock"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.NSRecursiveLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-pthread-mutex-recursive"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.pthread_mutex(recursive)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁（Read-write-Lock）"><span class="nav-number">2.5.</span> <span class="nav-text">读写锁（Read-write Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread-rwlock"><span class="nav-number">2.5.1.</span> <span class="nav-text">pthread_rwlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布锁（Didtributed-Lock）"><span class="nav-number">2.6.</span> <span class="nav-text">分布锁（Didtributed Lock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSDistributedLock（macOS）"><span class="nav-number">2.6.1.</span> <span class="nav-text">NSDistributedLock（macOS）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD"><span class="nav-number">3.</span> <span class="nav-text">GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore-信号量"><span class="nav-number">3.1.</span> <span class="nav-text">dispatch_semaphore 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier-栅栏"><span class="nav-number">3.2.</span> <span class="nav-text">Barrier 栅栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Queue-串行队列"><span class="nav-number">3.3.</span> <span class="nav-text">Serial Queue 串行队列</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
